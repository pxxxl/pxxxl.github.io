<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Cozard 的官方博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Cozard 技术空间">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Cozard 技术空间">
<meta property="og:description" content="Cozard 的官方博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZYZ">
<meta property="article:tag" content="Code Program Method">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Cozard 技术空间</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Cozard 技术空间</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">规划、设计、探索</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZYZ"
      src="/%5Cimages%5CdeltaruneNew%20(2).jpg">
  <p class="site-author-name" itemprop="name">ZYZ</p>
  <div class="site-description" itemprop="description">Cozard 的官方博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/pxxxl" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;pxxxl" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/wang-lang-pai-ma-wu-dao/posts" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;wang-lang-pai-ma-wu-dao&#x2F;posts" rel="noopener" target="_blank"><i class="fa-brands fa-zhihu fa-fw"></i>Zhihu</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-9-Y-%E7%BB%84%E5%90%88%E5%AD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/%5Cimages%5CdeltaruneNew%20(2).jpg">
      <meta itemprop="name" content="ZYZ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cozard 技术空间">
      <meta itemprop="description" content="Cozard 的官方博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cozard 技术空间">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-9-Y-%E7%BB%84%E5%90%88%E5%AD%90/" class="post-title-link" itemprop="url">untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-19 12:48:53 / 修改时间：12:49:05" itemprop="dateCreated datePublished" datetime="2022-09-19T12:48:53+08:00">2022-09-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Y-组合子（Y-Combinator）只是一个听起来很厉害，也很难的概念，然而实践上没有什么太大价值，因为它性能较低。不过学习它能让我们更好地理解函数式编程。</p>
<p>Y-combinator由Haskell Brooks Curry提出，Haskell的那个Haskell，Curry的那个Curry。</p>
<p><img src="/../images/untitled/202204102202393.png" alt="img"></p>
<hr>
<h2 id="不动点（fixed-point）"><a href="#不动点（fixed-point）" class="headerlink" title="不动点（fixed-point）"></a>不动点（fixed-point）</h2><p>想像一个函数G，它接收一个函数F作为参数，返回另一个函数。</p>
<p>如果满足<strong>F = G（F）</strong>则称F为G的不动点</p>
<p>如果F是G的不动点，那么：<strong>F = G（F）=G（G（F））=G（G（G（F）））= ……</strong></p>
<h2 id="匿名递归"><a href="#匿名递归" class="headerlink" title="匿名递归"></a>匿名递归</h2><p>想象一个匿名函数（为了方便称呼，给它名字M），它接收一个函数<strong>f</strong>，然后在其函数体内调用<strong>f</strong>。</p>
<p>在此基础上，如果这样定义一个函数：<strong>Func = M（Func）</strong>；</p>
<p>这样Func将成为递归函数，因为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Func（）</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">M（Func）（）</span><br><span class="line"><span class="comment">//M在函数体内调用Func，于是相当于</span></span><br><span class="line">Func（）</span><br></pre></td></tr></table></figure>

<p>无限递归。</p>
<p>然而如果在M的函数体内加上递归终止条件与迭代条件，Func就能成为一个真正的递归函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">auto</span> M = [](接收<span class="type">int</span> a返回<span class="type">int</span> b的函数)&#123;</span><br><span class="line">    <span class="keyword">return</span> a == <span class="number">0</span> ? <span class="number">1</span> : 函数(a - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func&lt;<span class="built_in">int</span>(<span class="type">int</span>)&gt; = <span class="built_in">M</span>(Func);</span><br><span class="line"><span class="comment">//Func是阶乘递归</span></span><br></pre></td></tr></table></figure>

<p>成功用M构造了递归。注意看M的表达式，当M返回函数的时候：</p>
<p><strong>Func = M（Func）；</strong></p>
<p>Func成为了M的不动点，同时Func自己是递归函数。</p>
<p>显然，如果需要写一个匿名递归函数，M部分是能很快写出来的，因为M知道递归函数的名字Func，M可以在自己的函数体里面写Func的递归逻辑，就像在Func的函数体里一样。</p>
<p>难点在已知M的情况下找出Func，是否能找到这样一个具有普遍性的函数，它接收M，返回Func？</p>
<hr>
<h3 id="数学推导格式规定"><a href="#数学推导格式规定" class="headerlink" title="数学推导格式规定"></a>数学推导格式规定</h3><h4 id="规则一："><a href="#规则一：" class="headerlink" title="规则一："></a>规则一：</h4><p><img src="/../images/untitled/91ff51ec92b238f5dfe8ef2e063d0906.svg+xml" alt="img">             </p>
<p><img src="/../images/untitled/9a14c5c608787364742381e8e29ffa32.svg+xml" alt="img">       </p>
<h4 id="规则二："><a href="#规则二：" class="headerlink" title="规则二："></a>规则二：</h4><p><img src="/../images/untitled/09ab8f6be57635bac6a78da3382ee55e.svg+xml" alt="img"></p>
<h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>化简式子</p>
<p><img src="/../images/untitled/9056be8a47e563b97de6fe43cc84b3db.svg+xml" alt="img"></p>
<p>可以看到，左边括号里是一个函数，用7来调用它，得</p>
<p><img src="/../images/untitled/ce99cd4785cbe6d20163fdd34035f8a8.svg+xml" alt="img"></p>
<p>可以看到，左边括号里是一个函数，用2来调用它，得</p>
<p><img src="/../images/untitled/b15983bcda2a67366d095cfeb326717a.svg+xml" alt="img"></p>
<p>很好，现在你已经掌握这套推导规则了，现在让我们引入Y-组合子吧！</p>
<hr>
<h2 id="Y-组合子"><a href="#Y-组合子" class="headerlink" title="Y-组合子"></a>Y-组合子</h2><p>Haskell Curry找到了一个函数 Y-组合子，它的形式是这样的：</p>
<p><img src="/../images/untitled/3fa37fb6ebde9b09d29c0fbdd3dc8a29.svg+xml" alt="img"></p>
<p>它有这样的性质：（F是函数）</p>
<p><img src="/../images/untitled/d763a13dd9181f5337fb115964e267e0.svg+xml" alt="img"></p>
<p>即<strong>Y（F）是 F 的不动点</strong></p>
<p>下面开始数学证明：</p>
<p><img src="/../images/untitled/a1788572a58fc8c6ce72f5b8e01da2d4.svg+xml" alt="img"></p>
<p><img src="/../images/untitled/ed1dec5f2850001dbe70263aa3e1dd8b.svg+xml" alt="img"></p>
<p>//注意了要把<img src="/../images/untitled/90232451b8a642d14d6fd5aa82e64078.svg+xml" alt="img">当成一个整体来调用函数了</p>
<p><img src="/../images/untitled/64e1e19aad9d4789269f597a028d4b24.svg+xml" alt="img"></p>
<p><img src="/../images/untitled/9af8d2e20db9e47df739977c6a666ae2.svg+xml" alt="img"></p>
<p>证毕。</p>
<h2 id="利用Y-组合子实现匿名递归"><a href="#利用Y-组合子实现匿名递归" class="headerlink" title="利用Y-组合子实现匿名递归"></a>利用Y-组合子实现匿名递归</h2><p>比照前面的几个式子：</p>
<p><img src="/../images/untitled/43ab695f75e7cea0f1def91c29f284df.svg+xml" alt="img"></p>
<p><img src="/../images/untitled/0e1ae1382c298342cc3002ea13927f20.svg+xml" alt="img"></p>
<p>其中Func是递归函数。</p>
<p>不妨令 Y（F）= Func ，M = F，上述公式完全成立</p>
<p>代换，得：</p>
<p><img src="/../images/untitled/c382f38ae8cddfb2677250ecd58e3b8f.svg+xml" alt="img"></p>
<p>成功了。</p>
<h2 id="C-实现Y-组合子"><a href="#C-实现Y-组合子" class="headerlink" title="C++实现Y-组合子"></a>C++实现Y-组合子</h2><p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Y = [](<span class="keyword">auto</span>&amp;&amp; f)&#123;</span><br><span class="line">    <span class="keyword">return</span> [&amp;f](<span class="keyword">auto</span>&amp;&amp; x)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>([&amp;x](<span class="keyword">auto</span>&amp;&amp; y)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">x</span>(x)(y);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;[&amp;f](<span class="keyword">auto</span>&amp;&amp; x)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>([&amp;x](<span class="keyword">auto</span>&amp;&amp; y)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">x</span>(x)(y);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>来使用一下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> M = [](<span class="keyword">auto</span>&amp;&amp; f)&#123;</span><br><span class="line">    <span class="keyword">return</span> [](<span class="type">int</span> n)&#123;</span><br><span class="line">        n == <span class="number">0</span> ? <span class="number">1</span> : <span class="built_in">f</span>(n);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> factorial = <span class="built_in">compose</span>(Y, M);</span><br></pre></td></tr></table></figure>

<p>这样就完成了匿名递归函数的编写。</p>
<p>对了还有个可优化的点，还记得我们之前说过的柯里化吗，既然Y组合子每次使用时都要和M函数结合，为什么我们不把Y组合子直接固定在compose里呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> rec = <span class="built_in">curry</span>(compose)(Y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> factorial = <span class="built_in">rec</span>(M);</span><br></pre></td></tr></table></figure>

<p>简洁，优雅，这便是函数式编程的魅力。</p>
<hr>
<p>这时候你可能已筋疲力竭，不禁会想，弄这个开销巨大，对于递归编写又没多少简化的东西干什么呢？我想说的是，编程不仅仅是枯燥乏味的增删改查——</p>
<p>一轮精妙的推导，一节优美的实现，一段如诗的代码，才是程序员的浪漫与追求。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-8-%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/%5Cimages%5CdeltaruneNew%20(2).jpg">
      <meta itemprop="name" content="ZYZ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cozard 技术空间">
      <meta itemprop="description" content="Cozard 的官方博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cozard 技术空间">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-8-%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">操作容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-19 12:47:55 / 修改时间：12:48:14" itemprop="dateCreated datePublished" datetime="2022-09-19T12:47:55+08:00">2022-09-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在函数式编程中，变量是不可变的，当产生一个新值时，我们创造一个新变量来“代表”它，而不是“修改”现有的变量。</p>
<p>对于容器也是一样，对容器的操作不会改变现有容器里的值以及容器本身，而是产生一个新的容器，里面装着新的值。</p>
<p>可以使用C++标准库自带的**std::vector(C++11)**作为容器，也可以自己写一个。</p>
<p>这里把vector重新命个名，叫seq。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">using</span> seq = std::vector&lt;T&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h2><p>与命令式编程不同，函数式编程操作容器往往不是靠下标，而是用一组可复用的函数和功能函数进行组合来整体操作容器。</p>
<p>有点绕口，来直接看实例。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>将容器中的每个值用传入的函数映射成新的值，然后装入新的容器中，看例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> increase = [](<span class="type">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> new_vec = <span class="built_in">map</span>(vec, increase);</span><br><span class="line"></span><br><span class="line"><span class="comment">//new_vec : &#123;2, 3, 4, 5, 6&#125;</span></span><br></pre></td></tr></table></figure>

<p>下面是针对std::vector的map的一种实现<strong>（C++11）</strong>，你也可以实现自己的版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">map</span><span class="params">(seq&lt;T&gt; vec, F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">    seq new_vec = vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; my_array.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        new_vec[i] = std::forward&lt;F&gt;(f)(new_vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>将容器中满足某个条件的值复制到新的容器中，看例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>&gt; my_array&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> judge = [](<span class="type">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> new_array = <span class="built_in">filter</span>(my_array, judge);</span><br><span class="line"></span><br><span class="line"><span class="comment">//new_array : &#123;4, 5&#125;</span></span><br></pre></td></tr></table></figure>

<p>下面是针对std::vector的filter的一种实现<strong>（C++11）</strong>，你也可以实现自己的版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">filter</span><span class="params">(std::seq&lt;T&gt; vec, F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">    std::seq&lt;T&gt; n_vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> value : vec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(value)) &#123;</span><br><span class="line">            n_vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n_vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>这个用图片更易理解</p>
<p><img src="/../images/untitled/202204102002831.png" alt="img"></p>
<p>reduce接收三个参数，第一个是列表，第二个是接收两个参数的函数，第三个是初始值，返回一个值。</p>
<p>来实现reduce</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F, <span class="keyword">typename</span> Init&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">reduce</span><span class="params">(seq&lt;T&gt; vec, F&amp;&amp; f, Init&amp;&amp; init)</span> </span>&#123;</span><br><span class="line">    std::<span class="type">decay_t</span>&lt;Init&gt; v;</span><br><span class="line">    v = init;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">if</span> <span class="params">(vec.size() == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; value : vec ) &#123;</span><br><span class="line">        v = <span class="built_in">f</span>(v, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-7-%E5%87%BD%E5%AD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/%5Cimages%5CdeltaruneNew%20(2).jpg">
      <meta itemprop="name" content="ZYZ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cozard 技术空间">
      <meta itemprop="description" content="Cozard 的官方博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cozard 技术空间">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-7-%E5%87%BD%E5%AD%90/" class="post-title-link" itemprop="url">函子</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-19 12:46:34 / 修改时间：12:47:10" itemprop="dateCreated datePublished" datetime="2022-09-19T12:46:34+08:00">2022-09-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><em>从本节开始，我们就要接触“容器”了。在大多数情况下，函数式编程是操作放在“容器”中的数据而不是操作裸数据。让我们从最简单的容器——functor开始吧。</em></p>
<hr>
<h2 id="Functor（函子）"><a href="#Functor（函子）" class="headerlink" title="Functor（函子）"></a>Functor（函子）</h2><p>定义：</p>
<ul>
<li>函子必须是一个容器</li>
<li>函子必须有map方法，（map：接收一个函数，map用functor里的值调用这个函数，然后根据返回值构造一个新的函子。）</li>
</ul>
<p>来实现一个最简单的函子吧</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">functor_t</span> &#123;</span><br><span class="line">    T t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">functor_t</span>(T v) &#123; t = v; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">map</span><span class="params">(std::function&lt;T(T)&gt;&amp;&amp; mapping)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">functor_t</span>&lt;T&gt;(std::forward&lt;std::function&lt;<span class="built_in">T</span>(T)&gt;&gt;(mapping)(t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">functor_t</span>&lt;std::<span class="type">decay_t</span>&lt;T&gt;&gt; <span class="built_in">functor_of</span>(T&amp;&amp; t) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; std::forward&lt;T&gt;(t) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//约定俗成，functor应该有一个叫做of的方法来构建一个functor</span></span><br></pre></td></tr></table></figure>

<p>函数式编程里的计算大多是操作函子而不是操作函子里的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> functorA = <span class="built_in">functor</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add_3 = <span class="built_in">curry</span>(add)(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">auto</span> multiply_5 = <span class="built_in">curry</span>(multiply)(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">auto</span> mod_2 = <span class="built_in">curry</span>(mod)(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> print = [](<span class="keyword">auto</span>&amp;&amp; a)&#123;std::cout&lt;&lt;a;<span class="keyword">return</span> a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> processed = functorA.<span class="built_in">map</span>(add_3).<span class="built_in">map</span>(multiply_5).<span class="built_in">map</span>(mod_2).<span class="built_in">map</span>(is_even).<span class="built_in">map</span>(print);</span><br></pre></td></tr></table></figure>



<p>函子还可以连续调用，来看下面例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> num = <span class="built_in">functor_of</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> num_is_even = num.<span class="built_in">map</span>(is_even);</span><br><span class="line"><span class="comment">//num_is_even同样是一个functor</span></span><br><span class="line"></span><br><span class="line">num.map</span><br></pre></td></tr></table></figure>

<p>在函子的基础上添加某些特性可以构造特殊的函子。</p>
<h2 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h2><p>maybe是特殊的函子，它具有函子的所有特征，此外，它实现了“空值过滤”的功能。</p>
<p>它的map具有一种特点，如果maybe里的值是一个“空值”，那么map就会直接将maybe拷贝一份作为返回值，而不会尝试拿“空值”来调用传入的函数（如果调用了，可能会产生错误）。</p>
<p>来实现一下吧。</p>
<h2 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><p>applicative是特殊的函子，它具有函子的所有特征，此外，它实现了“apply”的功能。</p>
<p>如果一个applicative里装着值，另一个applicative里装着接收这个值的函数，装着值的applicative就可以apply另一个applicative，利用函数的返回值创建一个新的applicative。</p>
<h2 id="Monad（单子）"><a href="#Monad（单子）" class="headerlink" title="Monad（单子）"></a>Monad（单子）</h2><p>monad是特殊的函子，它具有函子的所有特征，此外，它实现了“flatmap”的功能。</p>
<p>有时处理函子时会出现“函子嵌套”，就是说函子内部储存的值也是一个函子。而monad的flatmap保证函子内部储存的值一定不是函子。（flatmap好比将嵌套的函子“拍平”）</p>
<p>来实现一下</p>
<h2 id="更美观的书写方式"><a href="#更美观的书写方式" class="headerlink" title="更美观的书写方式"></a>更美观的书写方式</h2><p>C++20的range库使用了类似Unix的“管道运算符”，可以让函子（以及一些容器）的函数调用变得极其优美。首先，我们需要重载functor的  |  运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">functor_t</span> &#123;</span><br><span class="line">    T t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">functor_t</span>(T v) &#123; t = v; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">map</span><span class="params">(std::function&lt;T(T)&gt;&amp;&amp; mapping)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">functor_t</span>&lt;T&gt;(std::forward&lt;std::function&lt;<span class="built_in">T</span>(T)&gt;&gt;(mapping)(t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">operator</span>|(std::function&lt;<span class="built_in">T</span>(T)&gt;&amp;&amp; mapping) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">functor_t</span>&lt;T&gt;(std::forward&lt;std::function&lt;<span class="built_in">T</span>(T)&gt;&gt;(mapping)(t));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">functor_t</span>&lt;std::<span class="type">decay_t</span>&lt;T&gt;&gt; <span class="built_in">functor_of</span>(T&amp;&amp; t) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; std::forward&lt;T&gt;(t) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质是map改了个名字，但是调用效果非常棒。</p>
<p>改写本章开头functor演示的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> processed = functorA</span><br><span class="line">    |add_3</span><br><span class="line">    |multiply_5</span><br><span class="line">    |mod_2</span><br><span class="line">    |is_even</span><br><span class="line">    |print</span><br><span class="line">    ;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>好看吧，这种写法清晰明朗，比一长条的map要易读。而且这种写法也符合无参风格（point-free），是函数式编程所提倡的！</p>
<p>接下来一章，我们将学习C++的range库，深入了解一下C++特色的函数式编程。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-6-%E5%B0%8F%E7%BB%93%E4%B8%80%E4%B8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/%5Cimages%5CdeltaruneNew%20(2).jpg">
      <meta itemprop="name" content="ZYZ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cozard 技术空间">
      <meta itemprop="description" content="Cozard 的官方博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cozard 技术空间">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-6-%E5%B0%8F%E7%BB%93%E4%B8%80%E4%B8%8B/" class="post-title-link" itemprop="url">小结一下</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-19 12:45:51 / 修改时间：12:46:29" itemprop="dateCreated datePublished" datetime="2022-09-19T12:45:51+08:00">2022-09-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在前面的章节中，我们已经初步学习了函数式编程的基本思维以及概念，下面来梳理一下：</p>
<hr>
<ul>
<li>函数式编程将函数作为一等公民</li>
<li>函数式编程是声明式的</li>
<li>函数式编程要求不要改变变量的值</li>
</ul>
<ul>
<li>尽量编写纯函数</li>
<li>使用组合函数将纯函数组合起来</li>
<li>使用std::function实现lambda的递归</li>
<li>使用组合函数时可以无视被组合函数的中间参数，这种风格叫做Point-Free</li>
<li>使用偏函数与柯里化减少函数的参数，最好降低至一个</li>
</ul>
<hr>
<p>在接下来的章节中，我们将要接触到“容器”以及对容器的操作。很多时候我们并不处理裸露在外面的值，而是处理被包裹在容器中的值。</p>
<p>我们还将接触到一些有趣的数学推导，见证Y-组合子是如何帮助我们实现匿名递归的。</p>
<ul>
<li>C++20对于Range的支持与管道运算符</li>
<li>对容器的操作</li>
<li>函子Functor以及衍生</li>
<li>Y-组合子与递归</li>
</ul>
<hr>
<p>我准备了一些题目，尝试着用函数式编程的思维解决他们。这些题目有助于加深你对函数式编程的理解。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-5-%E5%81%8F%E5%87%BD%E6%95%B0%E5%92%8C%E6%9F%AF%E9%87%8C%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/%5Cimages%5CdeltaruneNew%20(2).jpg">
      <meta itemprop="name" content="ZYZ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cozard 技术空间">
      <meta itemprop="description" content="Cozard 的官方博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cozard 技术空间">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-5-%E5%81%8F%E5%87%BD%E6%95%B0%E5%92%8C%E6%9F%AF%E9%87%8C%E5%8C%96/" class="post-title-link" itemprop="url">偏函数和柯里化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-19 12:44:17 / 修改时间：12:45:19" itemprop="dateCreated datePublished" datetime="2022-09-19T12:44:17+08:00">2022-09-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>函数式编程特别重视一元函数</strong></p>
<hr>
<h2 id="Partial（偏函数）"><a href="#Partial（偏函数）" class="headerlink" title="Partial（偏函数）"></a>Partial（偏函数）</h2><p>“偏函数”指：固定某个参数为特定值，然后返回一个接收余下参数的函数。这是一种减少参数的方式。</p>
<p>打个比方：我们已经有了greater函数，它接收两个参数a和b。</p>
<p>如果我想编写一个greater_than_6函数，就可以基于已有的greater函数，将参数b固定为6，这样，得到的新函数greater_than_6只接收一个参数。</p>
<p>来写一下partial</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Fx, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">partial</span><span class="params">(_Fx&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">bind_front</span>(f, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完了，<strong>C++20及以上适用</strong>。</p>
<p><em>也可以用C++标准库（C++11）提供的std::bind来固定参数：</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> more_than_6 = std::<span class="built_in">bind</span>(more, _1, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">more_than_6</span>(<span class="number">1</span>);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><em>以下是bind用法的归纳：</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="comment">//占位符被定义在这个名字空间里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//std::bind接收 n+1 个参数，其中n是函数参数的个数</span></span><br><span class="line"><span class="comment">//std::bind的第一个参数是函数名，后面的参数要么是具体的值，要么是占位符</span></span><br><span class="line"><span class="comment">//占位符类似这种：_1, _2, _3,......</span></span><br><span class="line"><span class="comment">//占位符表示 “生成的新函数的第n个参数” 将会被放在原函数的占位符位置。来看演示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> less_than_6 = std::<span class="built_in">bind</span>(more, <span class="number">6</span>, _1);</span><br><span class="line"><span class="comment">//看，一共只有一个占位符，这意味着新函数一共只会有一个参数</span></span><br><span class="line"><span class="comment">//调用这个新函数时，这个参数会被放进对应占位符的位置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">less_than_6</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//bind的顺序是(6, _1), 10被放进_1</span></span><br><span class="line"><span class="comment">//所以相当于调用：</span></span><br><span class="line"><span class="built_in">more</span>(<span class="number">6</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//来来来我们再比较一下</span></span><br><span class="line">std::<span class="built_in">bind</span>(more, <span class="number">6</span>, _1);</span><br><span class="line">       <span class="built_in">less_than_6</span>(<span class="number">10</span>);</span><br><span class="line">           <span class="built_in">more</span>(<span class="number">6</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//我想你已经大概明白了，来看看复杂的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> less = std::<span class="built_in">bind</span>(more, _2, _1);</span><br><span class="line"><span class="comment">//这次有两个占位符</span></span><br><span class="line"><span class="built_in">less</span>(<span class="number">6</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//6被放进占位符_1  ,因为它是新函数的第一个参数</span></span><br><span class="line"><span class="comment">//10被放进占位符_2 ,因为它是新函数的第二个参数</span></span><br><span class="line"><span class="comment">//bind的顺序是(_2, _1)</span></span><br><span class="line"><span class="comment">//所以等效于调用：</span></span><br><span class="line"><span class="built_in">more</span>(<span class="number">10</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Curry（柯里化）"><a href="#Curry（柯里化）" class="headerlink" title="Curry（柯里化）"></a>Curry（柯里化）</h2><p>柯里化是特殊的Partial（偏函数）。</p>
<p>它并不固定任何一个参数，被柯里化的函数有这样的行为：</p>
<ul>
<li>只接收一个或多个参数并固定它，返回一个被柯里化的接收剩余参数的函数</li>
<li>当所有参数都被固定时返回结果</li>
</ul>
<p>概念有点绕，来看演示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数名curry</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sum_of_three = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b, <span class="keyword">auto</span> c)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> curried = <span class="built_in">curry</span>(sum_of_three);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下的调用法等效</span></span><br><span class="line"><span class="built_in">sum_of_three</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);                   <span class="comment">//6</span></span><br><span class="line"><span class="built_in">curried_sum_of_three</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);           <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//理解柯里化函数的调用法</span></span><br><span class="line"><span class="keyword">auto</span> curried_sum_1 = <span class="built_in">curried</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> curried_sum_2 = <span class="built_in">curried_sum_1</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">auto</span> curried_sum_3 = <span class="built_in">curried_sum_2</span>(<span class="number">3</span>);   <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<p>标准库中没有这样的函数，我们来自己写一个：</p>
<p><strong>（利用C++20的concept弄的，早些版本的写法不熟练）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">curry_t</span> &#123;</span><br><span class="line">	F f;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">		<span class="title">requires</span> <span class="params">(std::is_invocable&lt;F, Args...&gt;::value)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span>&amp;</span></span><br><span class="line"><span class="function">		<span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">		-&gt;<span class="title">decltype</span><span class="params">(std::invoke(f, std::forward&lt;Args&gt;(args)...))</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> std::<span class="built_in">invoke</span>(f, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">		<span class="title">requires</span> <span class="params">(!std::is_invocable&lt;F, Args...&gt;::value)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span>&amp;</span></span><br><span class="line"><span class="function">		<span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(curry(partial(f, std::forward&lt;Args&gt;(args)...))))</span></span></span><br><span class="line"><span class="function">		-&gt;<span class="title">decltype</span><span class="params">(curry(partial(f, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">curry</span>(<span class="built_in">partial</span>(f, std::forward&lt;Args&gt;(args)...));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">		<span class="title">requires</span> <span class="params">(std::is_invocable&lt;F, Args...&gt;::value)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span>&amp;&amp;</span></span><br><span class="line"><span class="function">		<span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">		-&gt;<span class="title">decltype</span><span class="params">(std::invoke(f, std::forward&lt;Args&gt;(args)...))</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> std::<span class="built_in">invoke</span>(f, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">		<span class="title">requires</span> <span class="params">(!std::is_invocable&lt;F, Args...&gt;::value)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span>&amp;&amp;</span></span><br><span class="line"><span class="function">		<span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(curry(partial(f, std::forward&lt;Args&gt;(args)...))))</span></span></span><br><span class="line"><span class="function">		-&gt;<span class="title">decltype</span><span class="params">(curry(partial(f, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">curry</span>(<span class="built_in">partial</span>(f, std::forward&lt;Args&gt;(args)...));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">		<span class="title">requires</span> <span class="params">(std::is_invocable&lt;F, Args...&gt;::value)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span><span class="type">const</span> &amp;</span></span><br><span class="line"><span class="function">		<span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">		-&gt;<span class="title">decltype</span><span class="params">(std::invoke(f, std::forward&lt;Args&gt;(args)...))</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> std::<span class="built_in">invoke</span>(f, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">		<span class="title">requires</span> <span class="params">(!std::is_invocable&lt;F, Args...&gt;::value)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span><span class="type">const</span> &amp;</span></span><br><span class="line"><span class="function">		<span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(curry(partial(f, std::forward&lt;Args&gt;(args)...))))</span></span></span><br><span class="line"><span class="function">		-&gt;<span class="title">decltype</span><span class="params">(curry(partial(f, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">curry</span>(<span class="built_in">partial</span>(f, std::forward&lt;Args&gt;(args)...));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">		<span class="title">requires</span> <span class="params">(std::is_invocable&lt;F, Args...&gt;::value)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span><span class="type">const</span> &amp;&amp;</span></span><br><span class="line"><span class="function">		<span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">		-&gt;<span class="title">decltype</span><span class="params">(std::invoke(f, std::forward&lt;Args&gt;(args)...))</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> std::<span class="built_in">invoke</span>(f, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">		<span class="title">requires</span> <span class="params">(!std::is_invocable&lt;F, Args...&gt;::value)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span><span class="type">const</span> &amp;&amp;</span></span><br><span class="line"><span class="function">		<span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(curry(partial(f, std::forward&lt;Args&gt;(args)...))))</span></span></span><br><span class="line"><span class="function">		-&gt;<span class="title">decltype</span><span class="params">(curry(partial(f, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">curry</span>(<span class="built_in">partial</span>(f, std::forward&lt;Args&gt;(args)...));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">curry_t</span>&lt;std::<span class="type">decay_t</span>&lt;F&gt;&gt; <span class="built_in">curry</span>(F&amp;&amp; f)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; std::forward&lt;F&gt;(f) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外说一下，纯粹的curry严格地让函数一次只接收一个参数，而上面的curry要求更宽松，你可以一次传几个参数进去。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-4-%E8%83%B6%E6%B0%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/%5Cimages%5CdeltaruneNew%20(2).jpg">
      <meta itemprop="name" content="ZYZ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cozard 技术空间">
      <meta itemprop="description" content="Cozard 的官方博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cozard 技术空间">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-4-%E8%83%B6%E6%B0%B4/" class="post-title-link" itemprop="url">胶水</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-19 12:39:56 / 修改时间：12:40:40" itemprop="dateCreated datePublished" datetime="2022-09-19T12:39:56+08:00">2022-09-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>已经编写了一些小型函数，我们来看看它们可以如何变化与组合</strong></p>
<p><strong>记住法则一：函数是一等公民。</strong></p>
<hr>
<h2 id="函数否定"><a href="#函数否定" class="headerlink" title="函数否定"></a>函数否定</h2><p>希望编写一个函数，它接收另一个函数，返回这个函数的否定函数。</p>
<p>C++17标准库提供了这个函数：std::not_fn</p>
<p>（接收一个返回bool类型的函数，返回一个反转原函数返回值的新函数）</p>
<p>来试一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> is_odd = [](<span class="keyword">auto</span> a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a % <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> is_even = std::<span class="built_in">not_fn</span>(is_odd);</span><br><span class="line"><span class="comment">//判断奇偶的函数</span></span><br><span class="line"><span class="comment">//其中判断偶的函数没有直接编写，而是从判断奇的函数中直接生成</span></span><br></pre></td></tr></table></figure>

<p>把函数当作参数，“函数式编程”是不是有点意思了？再来看这个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> not_equ = std::<span class="built_in">not_fn</span>(eq);</span><br><span class="line"><span class="comment">//从 “等于” 函数中直接生成 “不等于” 函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">not_equ</span>(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">eq</span>(<span class="number">1</span>, <span class="number">2</span>);         <span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<h2 id="函数或，函数与"><a href="#函数或，函数与" class="headerlink" title="函数或，函数与"></a>函数或，函数与</h2><p>有了逻辑非，怎能没有逻辑或和逻辑与呢？但很遗憾，标准库没有提供。</p>
<p>怕什么，学C++的最会造轮子了！来写一下试试。</p>
<p>（注：若看不懂，建议复制粘贴直接用，这部分的语法我将在“模板元编程”部分讲解。）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数逻辑或</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F1</span>, <span class="keyword">class</span> <span class="title class_">F2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">or_fn_t</span> &#123;</span><br><span class="line">    F1 f1;</span><br><span class="line">    F2 f2;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> &amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f1, std::forward&lt;Args&gt;(args)...) || std::<span class="built_in">invoke</span>(f2, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span><span class="type">const</span> &amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f1, std::forward&lt;Args&gt;(args)...) || std::<span class="built_in">invoke</span>(f2, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> &amp;&amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f1, std::forward&lt;Args&gt;(args)...) || std::<span class="built_in">invoke</span>(f2, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> <span class="type">const</span> &amp;&amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f1, std::forward&lt;Args&gt;(args)...) || std::<span class="built_in">invoke</span>(f2, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F1</span>, <span class="keyword">class</span> <span class="title class_">F2</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">or_fn_t</span>&lt;std::<span class="type">decay_t</span>&lt;F1&gt;, std::<span class="type">decay_t</span>&lt;F2&gt;&gt; <span class="built_in">or_fn</span>(F1&amp;&amp; f1, F2&amp;&amp; f2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; std::forward&lt;F1&gt;(f1), std::forward&lt;F2&gt;(f2) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数逻辑与</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F1</span>, <span class="keyword">class</span> <span class="title class_">F2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">and_fn_t</span> &#123;</span><br><span class="line">    F1 f1;</span><br><span class="line">    F2 f2;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> &amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::<span class="built_in">invoke</span>(f2, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span><span class="type">const</span>&amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::<span class="built_in">invoke</span>(f2, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> &amp;&amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::<span class="built_in">invoke</span>(f2, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> <span class="type">const</span>&amp;&amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::<span class="built_in">invoke</span>(f2, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F1</span>, <span class="keyword">class</span> <span class="title class_">F2</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">and_fn_t</span>&lt;std::<span class="type">decay_t</span>&lt;F1&gt;, std::<span class="type">decay_t</span>&lt;F2&gt;&gt; <span class="built_in">and_fn</span>(F1&amp;&amp; f1, F2&amp;&amp; f2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; std::forward&lt;F1&gt;(f1), std::forward&lt;F2&gt;(f2) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有两个函数 or_fn 和 and_fn。</p>
<p>(接收两个参数完全相同且返回bool类型的函数，返回经过逻辑组合的新函数）</p>
<p>来用一下试试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> eq_less = <span class="built_in">or_fn</span>(eq, less);</span><br><span class="line"><span class="comment">//“小于”和“等于”通过 逻辑或 生成“小于等于”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> greater = <span class="built_in">not_fn</span>(eq_less);</span><br><span class="line"><span class="comment">//否定 “小于等于” 来生成 “大于”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> eq_greater = <span class="built_in">or_fn</span>(eq, greater);</span><br><span class="line"><span class="comment">//简单粗暴的 “或” 组合</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eq_greater</span>(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">//false</span></span><br><span class="line"><span class="built_in">greater</span>(<span class="number">2</span>, <span class="number">1</span>);       <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>现在，你体会到函数式编程所说的“函数是一等公民”了吗？</p>
<p>凭借类似于“胶水”的组合函数，我们能像变量一样操纵、组合与生成新函数。</p>
<h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><p>数学中有“复合函数”这一概念。复合函数将前一个函数的输出用作下一个函数的输入，来看几张图：</p>
<p>（图引用自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74777206%EF%BC%89">https://zhuanlan.zhihu.com/p/74777206）</a></p>
<p><img src="/../images/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-4-%E8%83%B6%E6%B0%B4/202204081549052.png" alt="img"></p>
<p><strong>命令式编程存在一系列中间变量</strong></p>
<p><img src="/../images/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-4-%E8%83%B6%E6%B0%B4/202204081551629.png" alt="img"></p>
<p><strong>函数式编程</strong></p>
<p><img src="/../images/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-4-%E8%83%B6%E6%B0%B4/202204081553000.png" alt="img"></p>
<p><strong>函数组合</strong></p>
<p>在函数式编程中我们称此为“函数组合”（compose），函数组合是生成新函数的重要途径。</p>
<p>C++标准库没有“函数组合”函数，所以又到了喜闻乐见的造轮子时间~</p>
<p>（注：若看不懂，建议复制粘贴直接用，这部分的语法我将在“模板元编程”部分讲解。）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数组合，从右往左执行</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F1</span>, <span class="keyword">class</span> <span class="title class_">F2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">compose_t</span> &#123;</span><br><span class="line">    F1 f1;</span><br><span class="line">    F2 f2;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> &amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...))))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f1, std::<span class="built_in">invoke</span>(f2, std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> <span class="type">const</span> &amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...))))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f1, std::<span class="built_in">invoke</span>(f2, std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> &amp;&amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...))))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f1, std::<span class="built_in">invoke</span>(f2, std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> <span class="type">const</span> &amp;&amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...))))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f1, std::<span class="built_in">invoke</span>(f2, std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F1</span>, <span class="keyword">class</span> <span class="title class_">F2</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">compose_t</span>&lt;std::<span class="type">decay_t</span>&lt;F1&gt;, std::<span class="type">decay_t</span>&lt;F2&gt;&gt; <span class="built_in">compose</span>(F1&amp;&amp; f1, F2&amp;&amp; f2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; std::forward&lt;F1&gt;(f1), std::forward&lt;F2&gt;(f2) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F1</span>, <span class="keyword">class</span> <span class="title class_">F2</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">compose_t</span>&lt;std::<span class="type">decay_t</span>&lt;F1&gt;, std::<span class="type">decay_t</span>&lt;<span class="type">compose_t</span>&lt;F2, Args...&gt;&gt;&gt; <span class="built_in">compose</span>(F1&amp;&amp; f1, F2&amp;&amp; f2, Args&amp;&amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; std::forward&lt;F1&gt;(f1), std::forward&lt;<span class="type">compose_t</span>&lt;F2, Args...&gt;&gt;(<span class="built_in">compose</span>(f2, args)) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数组合，从左往右执行</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F1</span>, <span class="keyword">class</span> <span class="title class_">F2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_t</span> &#123;</span><br><span class="line">    F1 f1;</span><br><span class="line">    F2 f2;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> &amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...))))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f2, std::<span class="built_in">invoke</span>(f1, std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> <span class="type">const</span>&amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...))))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f2, std::<span class="built_in">invoke</span>(f1, std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> &amp;&amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...))))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f2, std::<span class="built_in">invoke</span>(f1, std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> <span class="type">const</span>&amp;&amp;</span></span><br><span class="line"><span class="function">        <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...))))</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f2, std::<span class="built_in">invoke</span>(f1, std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F1</span>, <span class="keyword">class</span> <span class="title class_">F2</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">pipe_t</span>&lt;std::<span class="type">decay_t</span>&lt;F1&gt;, std::<span class="type">decay_t</span>&lt;F2&gt;&gt; <span class="built_in">pipe</span>(F1&amp;&amp; f1, F2&amp;&amp; f2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; std::forward&lt;F1&gt;(f1), std::forward&lt;F2&gt;(f2) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args, <span class="keyword">class</span> <span class="title class_">F1</span>, <span class="keyword">class</span> <span class="title class_">F2</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">pipe_t</span>&lt;std::<span class="type">decay_t</span>&lt;<span class="type">pipe_t</span>&lt;Args..., F1&gt;&gt;,std::<span class="type">decay_t</span>&lt;F2&gt;&gt; <span class="built_in">pipe</span>(Args&amp;&amp;... args, F1&amp;&amp; f1, F2&amp;&amp; f2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; std::forward&lt;<span class="type">pipe_t</span>&lt;Args..., F1&gt;&gt;(<span class="built_in">pipe</span>(f2, args)) ,std::forward&lt;F2&gt;(f2) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有了两个函数compose和pipe</p>
<p>演示一下用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compose和pipe接收任意个数的函数，返回经过组合的函数</span></span><br><span class="line"><span class="comment">//其中compose是从右向左组合，pipe是从左向右组合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sum_is_odd = <span class="built_in">compose</span>(is_odd, sum);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum_is_odd</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//相当于调用</span></span><br><span class="line"><span class="built_in">is_odd</span>(<span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">//结果是false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> mul_is_odd = <span class="built_in">pipe</span>(mul, is_odd);</span><br><span class="line"></span><br><span class="line"><span class="built_in">mul_is_odd</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//相当于调用</span></span><br><span class="line"><span class="built_in">is_odd</span>(<span class="built_in">mul</span>(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">//结果是true</span></span><br></pre></td></tr></table></figure>

<p>有了compose和pipe，我们能将一系列过程看作一个整体，从而忽略复杂的中间量，简化代码。</p>
<p>此外，注意到如果函数只接收一个参数，我们就有机会连续组合多个函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add_1 = [](<span class="type">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add_4 = <span class="built_in">compose</span>(add_1, add_1, add_1, add_1);</span><br><span class="line"><span class="comment">//只是举个例子，不必纠结实用性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">add_4</span>(<span class="number">1</span>);     <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>我们目前编写的大多数函数是多参数函数，在下一节我们来看看如何将多参数函数转化为单参数函数。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-3-%E7%A7%AF%E6%9C%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/%5Cimages%5CdeltaruneNew%20(2).jpg">
      <meta itemprop="name" content="ZYZ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cozard 技术空间">
      <meta itemprop="description" content="Cozard 的官方博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cozard 技术空间">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-3-%E7%A7%AF%E6%9C%A8/" class="post-title-link" itemprop="url">积木</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-19 12:38:07 / 修改时间：12:40:08" itemprop="dateCreated datePublished" datetime="2022-09-19T12:38:07+08:00">2022-09-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>下面我们来趁热打铁，编写一些简单的纯函数来练练手，逐渐熟悉函数式编程的思维方式。</p>
<p><em><strong>打开你的编辑器，和我一起写</strong></em></p>
<p><em><strong>这些纯函数将会在之后的学习中用到</strong></em></p>
<hr>
<h2 id="包装个简单的算数操作试试"><a href="#包装个简单的算数操作试试" class="headerlink" title="包装个简单的算数操作试试"></a>包装个简单的算数操作试试</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sum = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sub = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> mul = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> divi = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a % b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看上去没什么用，然而这种高度抽象的简单函数正是复杂函数的基础。</p>
<h2 id="接下来编写逻辑函数与比较函数"><a href="#接下来编写逻辑函数与比较函数" class="headerlink" title="接下来编写逻辑函数与比较函数"></a>接下来编写逻辑函数与比较函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> not_ = [](<span class="type">bool</span> a)&#123;</span><br><span class="line">    <span class="keyword">return</span> !a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> and_ = [](<span class="type">bool</span> a, <span class="type">bool</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a &amp;&amp; b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> or_ = [](<span class="type">bool</span> a, <span class="type">bool</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a || b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> xor_ = [](<span class="type">bool</span> a, <span class="type">bool</span> b)&#123;</span><br><span class="line">    <span class="built_in">return</span> (!a&amp;&amp;b)||(!b&amp;&amp;a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> less = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> eq = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a == b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数式编程有点像搭积木，我们先造好一些小型积木，到后面再看看它们能组合出什么好玩的大家伙来。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-2-%E5%BC%80%E5%90%AF%E6%96%B0%E4%B8%96%E7%95%8C%E7%9A%84%E5%A4%A7%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/%5Cimages%5CdeltaruneNew%20(2).jpg">
      <meta itemprop="name" content="ZYZ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cozard 技术空间">
      <meta itemprop="description" content="Cozard 的官方博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cozard 技术空间">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-2-%E5%BC%80%E5%90%AF%E6%96%B0%E4%B8%96%E7%95%8C%E7%9A%84%E5%A4%A7%E9%97%A8/" class="post-title-link" itemprop="url">开启新世界的大门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-19 00:11:00 / 修改时间：00:13:57" itemprop="dateCreated datePublished" datetime="2022-09-19T00:11:00+08:00">2022-09-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>无论是面向过程还是面向对象，都是一种“指令式编程”模式：程序员“告诉”机器怎么做事，把事情的解决方案一步步列出来。</p>
<p>与“指令式编程”对应的是“声明式编程”：程序员把重心放在“做什么”而不是“怎么做”。打个比方：使用数据库语言SQL时，用户是不必操心机器是怎么插入或者查找数据的，只需要一句声明“我要做什么”，机器便会自动寻找解决方案；此外，一些逻辑编程语言，也是“声明式”的。</p>
<p><strong>函数式编程偏向于“声明式编程”而不是“指令式编程”。</strong></p>
<p>万事开头难，学习函数式编程将是一段难忘的旅途，途中可能会有各种挫折，但请不要放弃，毕竟你连C++的基本语法都啃下来了，还有什么东西是学不会的呢？</p>
<hr>
<h2 id="函数式编程的优点"><a href="#函数式编程的优点" class="headerlink" title="函数式编程的优点"></a>函数式编程的优点</h2><h3 id="1-可读性强"><a href="#1-可读性强" class="headerlink" title="1. 可读性强"></a>1. 可读性强</h3><p>函数式编程的“声明式”特征意味着程序员将更多关注某个代码片段的“作用”而不是“实现细节”，其代码相较于其他编程范式具有较强的可读性。</p>
<p>需要注意的一点是，对于刚入门函数式编程的新手，函数式编程的一些概念很陌生难懂。出现这种情况的原因并不是因为函数式编程本身“难于阅读”，而仅仅是因为“不熟悉”。打个比方，C语言初学者对数组下标以0开始的迷惑，难道也是。</p>
<p>因此，想要体会到函数式编程的“强可读性”，前提就是要多多练习，熟悉函数式编程风格与思路。</p>
<p><img src="https://gitee.com/pxxxl/pxxl-drawing-bed/raw/master/img/202204062254854.png" alt="img"></p>
<h3 id="2-高强度复用"><a href="#2-高强度复用" class="headerlink" title="2. 高强度复用"></a>2. 高强度复用</h3><p>函数式编程代码抽象程度很高，粒度比较低，复用非常方便。</p>
<p>很多时候并不直接编写很大的函数，而是将小函数拼接组合，像用胶水粘合积木一样。显然，胶水能复用，部分积木也能复用。</p>
<p>实际编程中常用compose组合函数，curry柯里函数，not_fn取反函数。它们是高度抽象可复用函数的典范。</p>
<h3 id="3-适合高并发"><a href="#3-适合高并发" class="headerlink" title="3. 适合高并发"></a>3. 适合高并发</h3><p>现代微处理器晶体管数目增长放缓，而核心数增长加快，这意味着可并发的程序越来越有性能优势。</p>
<p>一般的指令式程序需要耗费一部分时间资源在线程/进程交互上面。而函数式编程因为没有中间状态，变量不可更改等特征，可以轻易支持高并发。</p>
<hr>
<h2 id="使用C-进行函数式编程"><a href="#使用C-进行函数式编程" class="headerlink" title="使用C++进行函数式编程"></a>使用C++进行函数式编程</h2><p>Haskell、Scala、JavaScript 等语言以函数式编程闻名，C++作为现代语言特性的“究极缝合怪”也紧紧跟上了时代的脚步。自C++11开始，C++陆续添加了不少好用的新特性用以支持函数式编程：</p>
<ul>
<li>auto类型推导</li>
<li>lambda表达式</li>
<li>std::function函数包装器</li>
<li>std::bind工具</li>
</ul>
<p>等等还有很多，我会在需要时一一阐述。</p>
<hr>
<h2 id="原教旨主义"><a href="#原教旨主义" class="headerlink" title="原教旨主义"></a>原教旨主义</h2><p>（原教旨主义：最严格的函数式编程要求）</p>
<p>鉴于你现在对函数式编程的印象可能是很抽象的，下面我向你灌输几个概念，以使你迅速适应函数式编程的思维方式。</p>
<p>。</p>
<p>。</p>
<p>。</p>
<p><strong>准备好哦~</strong></p>
<p>。</p>
<p>。</p>
<p>。</p>
<p><strong>开始！</strong></p>
<h3 id="法则零：函数是-数据的“映射”而不是“操作”的集合"><a href="#法则零：函数是-数据的“映射”而不是“操作”的集合" class="headerlink" title="法则零：函数是 数据的“映射”而不是“操作”的集合"></a>法则零：函数是 数据的“映射”而不是“操作”的集合</h3><p>在面向过程编程语言里，函数（function）是一组代码（或者说操作）的集合，现在，请你忘掉它们，回想起在数学中函数是如何定义的。</p>
<p><strong>函数为两集合间的一种对应关系：输入值集合中的每项元素皆能对应唯一一项输出值集合中的元素。</strong></p>
<p>“函数式编程”中的函数是<strong>数学意义</strong>上的函数。“<strong>函数</strong>”应该具有以下特点：</p>
<ul>
<li><strong>引用透明：函数的输出只依赖输入的值，与外界其他量没有任何关系。</strong></li>
<li><strong>无副作用：函数调用不会产生除运算之外其他效果，同一组数据永远得到相同的值。</strong></li>
</ul>
<p>我们称拥有这些特点的函数为 <strong>纯函数</strong> 。</p>
<h3 id="法则一：函数是一等公民"><a href="#法则一：函数是一等公民" class="headerlink" title="法则一：函数是一等公民"></a>法则一：函数是一等公民</h3><p>函数可以和变量一样，可以赋值给其他变量，也可以作为参数，传入一个函数，或者作为别的函数的返回值。</p>
<h3 id="法则二：变量不可修改"><a href="#法则二：变量不可修改" class="headerlink" title="法则二：变量不可修改"></a>法则二：变量不可修改</h3><p>函数式编程认为“状态量”是导致程序复杂难以分析的根源。程序在不同运行时刻具有不同的“状态”（比如说循环语句的计数变量、累加过程中的计数变量等等），这些状态量时常变化，使程序的复杂度大大增加。</p>
<p>因此，在函数式编程中，你应尽量不要修改变量，这意味着：</p>
<ul>
<li><strong>不要使用循环语句（应该使用递归）。</strong></li>
<li><strong>函数应当返回一个新变量而不是在原有变量上做修改（函数即是映射）。</strong></li>
</ul>
<h3 id="法则三：使用表达式而不是语句："><a href="#法则三：使用表达式而不是语句：" class="headerlink" title="法则三：使用表达式而不是语句："></a>法则三：使用表达式而不是语句：</h3><p>表达式是一段单纯的运算过程，总是有返回值，而语句是执行某种操作，没有返回值。</p>
<p>函数式编程中的每一步都是单纯的运算，而且都有返回值。</p>
<hr>
<p>完毕。</p>
<p>以上勾勒了函数式编程的轮廓，不理解也没关系，继续下面的章节，在实践中慢慢体会函数式编程的魅力。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-1-lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/%5Cimages%5CdeltaruneNew%20(2).jpg">
      <meta itemprop="name" content="ZYZ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cozard 技术空间">
      <meta itemprop="description" content="Cozard 的官方博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cozard 技术空间">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-1-lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">lambda 表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-19 00:10:57 / 修改时间：00:12:27" itemprop="dateCreated datePublished" datetime="2022-09-19T00:10:57+08:00">2022-09-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>熟悉一下C++函数式编程的主角：lambda表达式。</p>
<p><em>请将你的编译器版本调到C++17及以上。</em></p>
<hr>
<h3 id="定义一个labmda变量（C-11与C-14）"><a href="#定义一个labmda变量（C-11与C-14）" class="headerlink" title="定义一个labmda变量（C++11与C++14）"></a>定义一个labmda变量（C++11与C++14）</h3><p>labmda既是一个函数，也是一个变量（事实上，它是一个由编译器自动生成的可调用类），让我们先来看看labmda是什么样子的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[]()&#123;&#125;</span><br><span class="line"><span class="comment">//此即为labmda的基本结构</span></span><br><span class="line"><span class="comment">//记住labmda既是一个函数，也是一个变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func1 = []()&#123;&#125;;</span><br><span class="line"><span class="comment">//一般使用自动类型推导来定义labmda变量，因为通常labmda表达式的类型名很长</span></span><br><span class="line"><span class="comment">//现在我们拥有了一个叫func1的labmda表达式变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func2 = [](<span class="type">int</span> a)&#123;&#125;</span><br><span class="line"><span class="comment">//我们的func2现在可以接受一个int类型的变量作为参数</span></span><br><span class="line"><span class="comment">//但是它什么都不做</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func3 = [](<span class="type">int</span> a)&#123;</span><br><span class="line">    std::cout&lt;&lt;a;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//func3拥有了函数体，它打印传入的int类型的变量</span></span><br><span class="line"><span class="comment">//记住labmda既是一个函数，也是一个变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func4 = [](<span class="type">int</span> a)&#123;</span><br><span class="line">    std::cout&lt;&lt;a;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//func4拥有了返回值</span></span><br><span class="line"><span class="comment">//注意：可以不声明返回值类型，编译器会自己推导（C++14）</span></span><br><span class="line"><span class="comment">//如果需要声明返回值，就这样写（C++11）：</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func5 = [](<span class="type">int</span> a)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">    std::cout&lt;&lt;a;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，labmda已经拥有了一个函数所应该拥有的一切：</p>
<ul>
<li>传入参数</li>
<li>函数体</li>
<li>返回值</li>
<li>名字</li>
</ul>
<p>下面来使用它。</p>
<h3 id="使用labmda变量（C-11）"><a href="#使用labmda变量（C-11）" class="headerlink" title="使用labmda变量（C++11）"></a>使用labmda变量（C++11）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [](<span class="type">int</span> a)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">    std::cout&lt;&lt;a;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//可以将lambda表达式视为一个函数，像使用函数一样使用它。</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们来看看labmda的捕获列表。</p>
<h3 id="捕获列表（C-11）"><a href="#捕获列表（C-11）" class="headerlink" title="捕获列表（C++11）"></a>捕获列表（C++11）</h3><p>lambda表达式可以“捕获”目前所处位置可见的变量，然后在函数体里面操作这些变量。</p>
<p>来看例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> message = <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [message](<span class="type">int</span> a)&#123;</span><br><span class="line">        <span class="keyword">return</span> a + message;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出18</span></span><br></pre></td></tr></table></figure>

<p>将需要捕获的变量写进方括号，即可在函数体里面操作这个变量。（如果你在lambda函数体内使用了某个外部的局部变量又没有捕获，编译器会报错的。）</p>
<p>有两种捕获方式：</p>
<ul>
<li>值捕获：相当于把外部变量复制一份放进lambda函数体里。</li>
<li>引用捕获：相当于创建外部变量的引用放进lambda函数体里，在lambda函数体里修改这个变量将影响到对应外部变量的值。</li>
</ul>
<p>来看例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var1 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> var2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> var3 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func1 = [var1]()&#123;&#125;;</span><br><span class="line"><span class="comment">//这是默认情况，值捕获</span></span><br><span class="line"><span class="keyword">auto</span> func1 = [var1, var2]()&#123;&#125;;</span><br><span class="line"><span class="comment">//这是默认情况，值捕获，而且捕获了两个变量。</span></span><br><span class="line"><span class="keyword">auto</span> func2 = [&amp;var1]()&#123;&#125;;</span><br><span class="line"><span class="comment">//这是引用捕获</span></span><br><span class="line"><span class="keyword">auto</span> func3 = [=]()&#123;&#125;;</span><br><span class="line"><span class="comment">//对所有变量进行值捕获</span></span><br><span class="line"><span class="keyword">auto</span> func4 = [&amp;]()&#123;&#125;;</span><br><span class="line"><span class="comment">//对所有变量进行引用捕获</span></span><br><span class="line"><span class="keyword">auto</span> func5 = [=,&amp;var2]()&#123;&#125;;</span><br><span class="line"><span class="comment">//var2进行引用捕获，其他所有变量进行值捕获</span></span><br></pre></td></tr></table></figure>

<p>基本语法就是这样，实际使用时可以自己类推。</p>
<p>（到这里你可能觉得捕获列表没啥用。我可以理解，你现在只需要简单了解一下，待会儿正式使用时你会惊叹它的威力的。）</p>
<h3 id="lambda参数自动类型推导（C-14）"><a href="#lambda参数自动类型推导（C-14）" class="headerlink" title="lambda参数自动类型推导（C++14）"></a>lambda参数自动类型推导（C++14）</h3><p><strong>C++14允许lambda表达式的参数类型是“auto”，编译器将在编译时自动推导其类型。</strong></p>
<hr>
<p>好，这样我们就学完lambda表达式的基本功能了。现在，让我们迈入函数式编程的旅途吧！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/18/Qt%E6%96%87%E6%A1%A3%E8%AF%91%E6%B3%A8-2-%E6%A8%A1%E5%9E%8B%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/%5Cimages%5CdeltaruneNew%20(2).jpg">
      <meta itemprop="name" content="ZYZ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cozard 技术空间">
      <meta itemprop="description" content="Cozard 的官方博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Cozard 技术空间">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/18/Qt%E6%96%87%E6%A1%A3%E8%AF%91%E6%B3%A8-2-%E6%A8%A1%E5%9E%8B%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">模型索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-18 23:59:06" itemprop="dateCreated datePublished" datetime="2022-09-18T23:59:06+08:00">2022-09-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-19 00:08:19" itemprop="dateModified" datetime="2022-09-19T00:08:19+08:00">2022-09-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Qt%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/" itemprop="url" rel="index"><span itemprop="name">Qt技术文档</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QModelIndex与QAbstractItemModel一同定义，用以索引模型（model）中的项（Item）。</span><br><span class="line"></span><br><span class="line">由于所有模型都是以“行“、”列”、“层级”结构组织的，我们可以使用统一的方式索引模型中的项。</span><br><span class="line"></span><br><span class="line">所有模型都使用QModelIndex作为模型的索引。</span><br><span class="line"></span><br><span class="line">QModelIndex内部包含了行信息、列信息与指向所属模型的指针，因此理论上可以做很多事。</span><br><span class="line"></span><br><span class="line">文档原文：https://doc.qt.io/qt-5/qmodelindex.html</span><br></pre></td></tr></table></figure>

<h2 id="详细信息"><a href="#详细信息" class="headerlink" title="详细信息"></a>详细信息</h2><p>这个类可以用作QAbstractModel以及从它所派生的模型的索引。“视图”（view）、“代理”（delegate）和“选择模型”（selection models）都使用索引来定位模型中的项。</p>
<p>QModelIndex 的默认构造函数只能创建无效索引，有效的QModelIndex对象应由模型使用QAbstractItemModel::createIndex 函数创建。模型中的最高级项的父索引是无效索引。</p>
<p>QModelIndex 不止一个构造函数，但是除了无参数的构造函数外，其他的构造函数（能创造出有效索引的构造函数）都被设置为私有</p>
<p>QAbstractItemModel 是 QModelIndex 的友元，它可以访问这些私有构造函数来创建出有效的索引。</p>
<p>所有模型都是 QAbstractItemModel 的子类（或间接子类），它们继承了QAbstractItemModel的createIndex函数。</p>
<p>QModelIndex可以用来引用模型中的项，它包含确定这个项在模型中的位置所需的所有信息。索引拥有行信息、列信息，并且可能拥有父索引，可以使用row()、column()和parent()函数来获取这些信息。模型中的每个<strong>顶级</strong>项都由一个没有父索引的模型索引表示，在这种情况下，parent()将返回一个无效的模型索引，这种情况相当于使用QModelIndex()来构造无效索引。</p>
<p>（Qt5.15）</p>
<p>QModelIndex 拥有这些私有变量：</p>
<p>​    int r, c;</p>
<p>​    quintptr i;</p>
<p>​    const QAbstractItemModel *m;</p>
<p>其中 r 与 c 是行列信息，m 是其所属的模型的指针。i 是用来把索引和底层数据结构联系起来的 void 指针。</p>
<p>QModelIndex 没有指向其父索引的指针，QModelIndex 的 parent 函数是通过调用其对应模型的 parent 函数实现的。</p>
<p>要获取模型中某个项的索引，请调用QAbstractIemModel::index()，这个函数需要三个参数：行数、列数、父索引的引用。引用模型中的顶级项时，应提供无效索引作为父索引。</p>
<p>QAbstractIemModel::index()是一个纯虚函数，各个模型有不同的实现。</p>
<p>接口：</p>
<p>QModelIndex QAbstractItemModel::index(int row, int column, const QModelIndex &amp;parent = QModelIndex()) const</p>
<p>第三个参数已经默认是无效索引，因此创建顶级项索引时传一个无效索引进去其实是多此一举。</p>
<p>model() 函数的作用是：返回索引对应模型的指针（const QAbstractItemModel*）。</p>
<p>child() 函数的作用是：获取该索引的子项目。</p>
<p>sibling() 函数的作用是：遍历模型中与本索引同级别的项。</p>
<p>注意：应立即使用模型索引，然后丢弃。在调用更改模型结构或删除项的模型函数后，不应认为索引仍然有效。如果需要长时间保留模型索引，请使用QPersistentModelIndex。</p>
<p>另请参见<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5.15/model-view-programming.html">模型/视图编程</a>、<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5.15/qpersistentmodelindex.html">QPersistentModelIndex</a>和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5.15/qabstractitemmodel.html">QAbstractItemModel。</a></p>
<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><h3 id="QModelIndex-QModelIndex"><a href="#QModelIndex-QModelIndex" class="headerlink" title="QModelIndex::QModelIndex()"></a>QModelIndex::QModelIndex()</h3><p>创建无效模型索引，用以指示模型中的某位置无效。</p>
<p>另请参见isValid()和<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5.15/qabstractitemmodel.html">QAbstractItemModel</a>。</p>
<h3 id="int-QModelIndex-column-const"><a href="#int-QModelIndex-column-const" class="headerlink" title="int QModelIndex::column()const"></a>int QModelIndex::column()const</h3><p>返回索引所引用的元素所在的列数。</p>
<h3 id="QVariant-QModelIndex-data-int-role-Qt-DisplayRole-const"><a href="#QVariant-QModelIndex-data-int-role-Qt-DisplayRole-const" class="headerlink" title="QVariant QModelIndex::data(int role=Qt::DisplayRole)const"></a>QVariant QModelIndex::data(int role=Qt::DisplayRole)const</h3><p>给定角色(role)，返回索引引用的项的数据。</p>
<h3 id="Qt-ItemFlags-QModelIndex-flags-const"><a href="#Qt-ItemFlags-QModelIndex-flags-const" class="headerlink" title="Qt::ItemFlags QModelIndex::flags() const"></a>Qt::ItemFlags QModelIndex::flags() const</h3><p>返回索引引用的项的标志(flag)。</p>
<p>此函数在Qt 4.2中引入。</p>
<h3 id="quintptr-QModelIndex-internalId-const"><a href="#quintptr-QModelIndex-internalId-const" class="headerlink" title="quintptr QModelIndex::internalId() const"></a>quintptr QModelIndex::internalId() const</h3><p>返回将索引与内部数据结构关联的quintptr，这个quintptr被模型所使用。</p>
<p>另请参见<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5.15/qabstractitemmodel.html#createIndex">QAbstractItemModel::createIndex()</a>。</p>
<h3 id="void-QModelIndex-internalPointer-const"><a href="#void-QModelIndex-internalPointer-const" class="headerlink" title="void* QModelIndex::internalPointer() const"></a>void* QModelIndex::internalPointer() const</h3><p>返回将索引与内部数据结构关联的void*指针，这个指针被模型所使用。</p>
<p>另请参见<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5.15/qabstractitemmodel.html#createIndex">QAbstractItemModel::createIndex()</a>。</p>
<h3 id="bool-QModelIndex-isValid-const"><a href="#bool-QModelIndex-isValid-const" class="headerlink" title="bool QModelIndex::isValid()const"></a>bool QModelIndex::isValid()const</h3><p>如果此模型索引有效，则返回true；否则返回false。</p>
<p>有效索引属于模型，并且具有非负的行号和列号。</p>
<p>另请参见model()、row()和column()。</p>
<p>如果模型索引内部那个指向模型的指针非空，而且行列数非负，那么这个索引有效。</p>
<h3 id="const-QAbstractItemModel-QModelIndex-model-const"><a href="#const-QAbstractItemModel-QModelIndex-model-const" class="headerlink" title="const QAbstractItemModel* QModelIndex::model()const"></a>const QAbstractItemModel* QModelIndex::model()const</h3><p>返回指向此索引对应模型的指针。</p>
<p>返回值是常量指针，因为调用模型的非常量函数可能会使模型索引无效，并可能使应用程序崩溃。</p>
<h3 id="QModelIndex-QModelIndex-parent-const"><a href="#QModelIndex-QModelIndex-parent-const" class="headerlink" title="QModelIndex QModelIndex::parent()const"></a>QModelIndex QModelIndex::parent()const</h3><p>返回模型索引的父索引，如果没有父索引，则返回QModelIndex()。</p>
<p>另请参见 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5.15/qmodelindex.html#sibling">sibling</a>() 和 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5.15/qmodelindex.html#model">model</a>()。</p>
<h3 id="int-QModelIndex-row-const"><a href="#int-QModelIndex-row-const" class="headerlink" title="int QModelIndex::row()const"></a>int QModelIndex::row()const</h3><p>返回索引所引用的元素所在的列数。</p>
<h3 id="QModelIndex-QModelIndex-sibling-int-row，int-column-const"><a href="#QModelIndex-QModelIndex-sibling-int-row，int-column-const" class="headerlink" title="QModelIndex QModelIndex::sibling(int row，int column)const"></a>QModelIndex QModelIndex::sibling(int row，int column)const</h3><p>返回该索引的兄弟。如果此位置没有兄弟，则返回无效的QModelIndex。</p>
<p>另请参见 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5.15/qmodelindex.html#parent">parent</a>(), <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5.15/qmodelindex.html#siblingAtColumn">siblingAtColumn</a>(), 和 <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5.15/qmodelindex.html#siblingAtRow">siblingAtRow</a>()。</p>
<h3 id="QModelIndex-QModelIndex-siblingAtColumn-int-column-const"><a href="#QModelIndex-QModelIndex-siblingAtColumn-int-column-const" class="headerlink" title="QModelIndex QModelIndex::siblingAtColumn(int column)const"></a>QModelIndex QModelIndex::siblingAtColumn(int column)const</h3><p>返回该索引的当前列的兄弟。如果此位置没有兄弟，则返回无效QModelIndex。</p>
<p>此函数在Qt 5.11中引入。</p>
<p>另请参见<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5.15/qmodelindex.html#sibling">sibling</a>() and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5.15/qmodelindex.html#siblingAtRow">siblingAtRow</a>()。</p>
<h3 id="QModelIndex-QModelIndex-siblingAtRow-int-row-const"><a href="#QModelIndex-QModelIndex-siblingAtRow-int-row-const" class="headerlink" title="QModelIndex QModelIndex::siblingAtRow(int row) const"></a>QModelIndex QModelIndex::siblingAtRow(int row) const</h3><p>返回该索引的当前行的兄弟。如果此位置没有兄弟，则返回无效QModelIndex。</p>
<p>此函数在Qt 5.11中引入。</p>
<p>另请参见<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5.15/qmodelindex.html#sibling">sibling</a>() and <a target="_blank" rel="noopener" href="https://doc.qt.io/qt-5.15/qmodelindex.html#siblingAtColumn">siblingAtColumn</a>()。</p>
<h3 id="bool-QModelIndex-operator-const-QModelIndex-amp-other-const"><a href="#bool-QModelIndex-operator-const-QModelIndex-amp-other-const" class="headerlink" title="bool QModelIndex::operator=(const QModelIndex &amp;other)const"></a>bool QModelIndex::operator=(const QModelIndex &amp;other)const</h3><p>如果此模型索引与其他模型索引引用的位置不同，则返回true；否则返回false。</p>
<h3 id="bool-QModelIndex-operator-lt-const-QModelIndex-amp-other-const"><a href="#bool-QModelIndex-operator-lt-const-QModelIndex-amp-other-const" class="headerlink" title="bool QModelIndex::operator&lt;(const QModelIndex &amp;other)const"></a>bool QModelIndex::operator&lt;(const QModelIndex &amp;other)const</h3><p>如果此模型索引小于其他模型索引，则返回true；否则返回false。</p>
<p>小于计算对开发人员没有直接的帮助，没有定义具有不同父级的索引进行比较的方式。此运算符的存在只是为了使该类可以与QMap一起使用。</p>
<p>Qt 4.1中引入了此函数。</p>
<h3 id="bool-QModelIndex-operator-const-QModelIndex-amp-other-const-1"><a href="#bool-QModelIndex-operator-const-QModelIndex-amp-other-const-1" class="headerlink" title="bool QModelIndex::operator==(const QModelIndex&amp; other)const"></a>bool QModelIndex::operator==(const QModelIndex&amp; other)const</h3><p>如果此模型索引引用的位置与其他模型索引相同，则返回true；否则返回false。</p>
<p>与其他模型索引进行比较时，将使用内部数据指针、行、列和模型值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa-regular fa-earth-asia"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZYZ</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  





  





</body>
</html>
