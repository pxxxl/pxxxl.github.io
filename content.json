{"meta":{"title":"Cozard 技术空间","subtitle":"规划、设计、探索","description":"Cozard 的官方博客","author":"ZYZ","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-09-18T15:40:42.000Z","updated":"2022-09-18T15:43:05.594Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-18T15:41:37.000Z","updated":"2022-09-18T15:42:24.344Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"模型索引","slug":"Qt文档译注-2-模型索引","date":"2022-09-18T15:59:06.000Z","updated":"2022-09-18T16:01:55.854Z","comments":true,"path":"2022/09/18/Qt文档译注-2-模型索引/","link":"","permalink":"http://example.com/2022/09/18/Qt%E6%96%87%E6%A1%A3%E8%AF%91%E6%B3%A8-2-%E6%A8%A1%E5%9E%8B%E7%B4%A2%E5%BC%95/","excerpt":"","text":"QModelIndex与QAbstractItemModel一同定义，用以索引模型（model）中的项（Item）。 由于所有模型都是以“行“、”列”、“层级”结构组织的，我们可以使用统一的方式索引模型中的项。 所有模型都使用QModelIndex作为模型的索引。 QModelIndex内部包含了行信息、列信息与指向所属模型的指针，因此理论上可以做很多事。 文档原文：https://doc.qt.io/qt-5/qmodelindex.html 详细信息这个类可以用作QAbstractModel以及从它所派生的模型的索引。“视图”（view）、“代理”（delegate）和“选择模型”（selection models）都使用索引来定位模型中的项。 QModelIndex 的默认构造函数只能创建无效索引，有效的QModelIndex对象应由模型使用QAbstractItemModel::createIndex 函数创建。模型中的最高级项的父索引是无效索引。 QModelIndex 不止一个构造函数，但是除了无参数的构造函数外，其他的构造函数（能创造出有效索引的构造函数）都被设置为私有 QAbstractItemModel 是 QModelIndex 的友元，它可以访问这些私有构造函数来创建出有效的索引。 所有模型都是 QAbstractItemModel 的子类（或间接子类），它们继承了QAbstractItemModel的createIndex函数。 QModelIndex可以用来引用模型中的项，它包含确定这个项在模型中的位置所需的所有信息。索引拥有行信息、列信息，并且可能拥有父索引，可以使用row()、column()和parent()函数来获取这些信息。模型中的每个顶级项都由一个没有父索引的模型索引表示，在这种情况下，parent()将返回一个无效的模型索引，这种情况相当于使用QModelIndex()来构造无效索引。 （Qt5.15） QModelIndex 拥有这些私有变量： ​ int r, c; ​ quintptr i; ​ const QAbstractItemModel *m; 其中 r 与 c 是行列信息，m 是其所属的模型的指针。i 是用来把索引和底层数据结构联系起来的 void 指针。 QModelIndex 没有指向其父索引的指针，QModelIndex 的 parent 函数是通过调用其对应模型的 parent 函数实现的。 要获取模型中某个项的索引，请调用QAbstractIemModel::index()，这个函数需要三个参数：行数、列数、父索引的引用。引用模型中的顶级项时，应提供无效索引作为父索引。 QAbstractIemModel::index()是一个纯虚函数，各个模型有不同的实现。 接口： QModelIndex QAbstractItemModel::index(int row, int column, const QModelIndex &amp;parent = QModelIndex()) const 第三个参数已经默认是无效索引，因此创建顶级项索引时传一个无效索引进去其实是多此一举。 model() 函数的作用是：返回索引对应模型的指针（const QAbstractItemModel*）。 child() 函数的作用是：获取该索引的子项目。 sibling() 函数的作用是：遍历模型中与本索引同级别的项。 注意：应立即使用模型索引，然后丢弃。在调用更改模型结构或删除项的模型函数后，不应认为索引仍然有效。如果需要长时间保留模型索引，请使用QPersistentModelIndex。 另请参见模型/视图编程、QPersistentModelIndex和QAbstractItemModel。 成员函数QModelIndex::QModelIndex()创建无效模型索引，用以指示模型中的某位置无效。 另请参见isValid()和QAbstractItemModel。 int QModelIndex::column()const返回索引所引用的元素所在的列数。 QVariant QModelIndex::data(int role=Qt::DisplayRole)const给定角色(role)，返回索引引用的项的数据。 Qt::ItemFlags QModelIndex::flags() const返回索引引用的项的标志(flag)。 此函数在Qt 4.2中引入。 quintptr QModelIndex::internalId() const返回将索引与内部数据结构关联的quintptr，这个quintptr被模型所使用。 另请参见QAbstractItemModel::createIndex()。 void* QModelIndex::internalPointer() const返回将索引与内部数据结构关联的void*指针，这个指针被模型所使用。 另请参见QAbstractItemModel::createIndex()。 bool QModelIndex::isValid()const如果此模型索引有效，则返回true；否则返回false。 有效索引属于模型，并且具有非负的行号和列号。 另请参见model()、row()和column()。 如果模型索引内部那个指向模型的指针非空，而且行列数非负，那么这个索引有效。 const QAbstractItemModel* QModelIndex::model()const返回指向此索引对应模型的指针。 返回值是常量指针，因为调用模型的非常量函数可能会使模型索引无效，并可能使应用程序崩溃。 QModelIndex QModelIndex::parent()const返回模型索引的父索引，如果没有父索引，则返回QModelIndex()。 另请参见 sibling() 和 model()。 int QModelIndex::row()const返回索引所引用的元素所在的列数。 QModelIndex QModelIndex::sibling(int row，int column)const返回该索引的兄弟。如果此位置没有兄弟，则返回无效的QModelIndex。 另请参见 parent(), siblingAtColumn(), 和 siblingAtRow()。 QModelIndex QModelIndex::siblingAtColumn(int column)const返回该索引的当前列的兄弟。如果此位置没有兄弟，则返回无效QModelIndex。 此函数在Qt 5.11中引入。 另请参见sibling() and siblingAtRow()。 QModelIndex QModelIndex::siblingAtRow(int row) const返回该索引的当前行的兄弟。如果此位置没有兄弟，则返回无效QModelIndex。 此函数在Qt 5.11中引入。 另请参见sibling() and siblingAtColumn()。 bool QModelIndex::operator=(const QModelIndex &amp;other)const如果此模型索引与其他模型索引引用的位置不同，则返回true；否则返回false。 bool QModelIndex::operator&lt;(const QModelIndex &amp;other)const如果此模型索引小于其他模型索引，则返回true；否则返回false。 小于计算对开发人员没有直接的帮助，没有定义具有不同父级的索引进行比较的方式。此运算符的存在只是为了使该类可以与QMap一起使用。 Qt 4.1中引入了此函数。 bool QModelIndex::operator==(const QModelIndex&amp; other)const如果此模型索引引用的位置与其他模型索引相同，则返回true；否则返回false。 与其他模型索引进行比较时，将使用内部数据指针、行、列和模型值。","categories":[],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"创建子类模型","slug":"Qt文档译注-1-创建子类模型","date":"2022-09-18T15:55:43.000Z","updated":"2022-09-18T16:01:53.818Z","comments":true,"path":"2022/09/18/Qt文档译注-1-创建子类模型/","link":"","permalink":"http://example.com/2022/09/18/Qt%E6%96%87%E6%A1%A3%E8%AF%91%E6%B3%A8-1-%E5%88%9B%E5%BB%BA%E5%AD%90%E7%B1%BB%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"子类模型需要提供 QabstractemModel 基类中定义的许多虚函数的实现。需要实现的函数数量取决于模型的类型——它是为视图提供简单的列表、表格还是复杂的项目层次结构。从 QAbstractListModel 和 QAbstractTableModel 继承的模型可以利用它们所提供函数的默认实现。以树状结构组织数据项的模型必须为QabstractemModel中的许多虚函数提供实现。 需要在模型子类中实现的功能可分为三组： 数据项处理：所有模型都需要实现功能，以使视图和委托能够查询模型的维度、检查项目和检索数据。 导引和索引创建：具有层次结构的模型需要提供视图可以调用的功能，以导引它们展示的树状结构；以及获取项的索引。 拖放支持和MIME类型处理：模型继承了控制内部和外部拖放操作的函数。这些函数允许按照其他组件和应用程序可以理解的MIME类型来描述数据项。 数据项处理模型可以提供对其提供的数据项的不同访问级别：它们可以是简单的只读项，或者能支持调整大小操作，有的甚至允许编辑。 只读权限如果模型提供的数据项是只读的，在子类中这些函数需要被实现： flags() 其他组件用于获取有关模型提供的每个项目的信息的标志在许多模型中，标志的组合应该包括Qt：：ItemIsEnabled和Qt：：ItemIsSelectable。 data() 用于向视图和委托提供项数据。通常，模型只需要为Qt：：DisplayRole和用户特定的角色(role)提供数据，但为Qt：：ToolTipRole、Qt：：AccessibleTextRole和Qt：：AccessibleDescriptionRole提供数据也是一种很好的做法。有关与每个角色关联的类型的信息，请参阅Qt：：ItemDataRole枚举文档。 headerData() 为视图提供要在其标头中显示的信息。该信息仅由可以显示标头信息的视图检索。 rowCount() 模型提供的数据行数 这四个函数必须在所有类型的模型中实现，包括列表模型（QAbstractListModel 子类）和表模型（QAbstractTableModel 子类）。 此外，必须在QAbstractTableModel和QAbstractItemModel的直接子类中实现以下功能： columnCount() 模型提供的数据列数。列表模型不提供此功能，因为它已在QAbstractListModel中实现。 可编辑数据项可编辑模型允许修改数据项，并可能提供允许插入和删除行和列的功能。要启用编辑，必须实现下列函数： flags() 必须为每个项目返回适当的标志(flag)组合。特别的，除了应用于只读模型中的项的值之外，此函数返回的值还必须包括Qt：：ItemIsEditable。 setData() 用于修改与指定模型索引关联的数据项。为了能够接受用户界面元素提供的用户输入，此函数必须处理与Qt：：EditRole关联的数据。该实现还可以接受与Qt：：ItemDataRole指定的许多不同类型的角色相关联的数据。更改数据项后，模型必须发出dataChanged（）信号，以通知其他组件该更改。 setHeaderData() 用于修改水平和垂直标头信息。更改数据项后，模型必须发出headerDataChanged（）信号，以通知其他组件该更改。 可变容量模型所有类型的模型都可以支持插入和删除行。表模型和层次模型还可以支持插入和删除列。而在模型尺寸发生更改之前和之后，要将更改通知给其他组件。因此，可实现以下函数以允许调整模型的容量，但这些函数的实现必须确保适当的函数被调用以通知与这个模型相连接的视图和委托： insertRows 用于向模型中添加新行和数据项。注意必须在插入操作之前调用beginInsertRows（），插入完成后立即调用endInsertRows（）。 removeRows 用于从所有类型的模型中删除行及其包含的数据项。在删除行之前，必须调用beginRemoveRows（），完成后立即调用endRemoveRows（）。 insertColumns 用于向模型中添加新列和数据项。注意必须在插入操作之前调用beginInsertColumns（），插入完成后立即调用endInsertColumns（）。 removeColumns 用于从所有类型的模型中删除列及其包含的数据项。在删除行之前，必须调用beginRemoveColumns（），完成后立即调用endRemoveColumns（）。 通常，如果操作成功，这些函数应返回true。然而，可能存在操作仅部分成功的情况；例如，可以插入的行数小于指定的行数。在这种情况下，模型应返回false以表示操作失败并指示相关组件处理这种情况。 在调整容量API的实现中调用函数发出的信号使相关的组件有机会在某些数据不可用之前采取行动。使用begin和end函数封装insert和remove操作，还可以使模型正确管理持久模型索引。 通常，begin和end函数能够通知其他组件模型底层结构的更改。对于模型结构的更复杂更改，可能涉及内部重组、数据排序或任何其他结构更改，有必要按顺序执行以下操作： 发出layoutAboutToBeChanged（）信号 更新表示模型结构的内部数据。 使用changePersistentIndexList（）更新持久索引 发出layoutChanged（）信号。 此序列可用于任何结构更新，是一种更高级和更方便的保护方法。例如，如果一个有200万行的模型需要删除所有奇数行，即有100万个长度为1的裁剪范围。可以使用beginRemoveRows和endRemoveRows 100万次，但这显然效率低下。相反，这可以视作一个布局更改来发出信号，它会立即更新所有必要的持久性索引。 模型数据的惰性填充模型数据的惰性填充有效地延迟对模型信息的请求，直到视图实际需要它为止。 一些模型需要从远程源获取数据，或者必须执行耗时的操作以获取有关数据组织方式的信息。由于视图通常要求尽可能多的信息以准确显示模型数据，因此限制返回给它们的信息量以减少不必要的后续数据请求可能会很有用。 在层次模型中，查找给定项的子项数量是一项代价高昂的操作，因此确保仅在必要时调用模型的rowCount（）非常有用。在这种情况下，可以重新实现hasChildren（）函数，为视图提供一种廉价的方法来检查子项的存在，对于QTreeView，draw the appropriate decoration for their parent item. 无论hasChildren（）的重新实现是否返回true或false，视图都可能不需要调用rowCount（）来确定存在多少子级。例如，如果父项未展开以显示子项，则QTreeView不需要知道有多少子项。 如果知道许多项都有子项，那么重新实现hasChildren（）以无条件返回true有时是一种有用的方法。这使得检查每个数据项子项的操作被推迟到之后进行，同时使模型数据的初始总体尽可能快。唯一的缺点是，没有子项的数据项可能在某些视图中显示不正确，直到用户尝试查看这些数据项。 导航(Navigation)和模型索引创建层次模型需要提供函数以导航它们公开的树状结构，供视图调用，并让视图可以获取项的索引。 父级和子级由于暴露给视图的结构由底层数据结构决定，因此每个模型子类都可以通过提供以下函数的实现来创建自己的模型索引： index 给定父项的模型索引，此函数允许视图和委托访问该项的子项。如果找不到与指定的行、列和父模型索引相对应的有效子项，则函数必须返回QModelIndex（），这是一个无效的模型索引。 parent 提供与任何给定子项的父项相对应的模型索引。如果指定的模型索引对应于模型中的顶级项，或者如果模型中没有有效的父项，则函数必须返回使用空QModelIndex（）构造函数创建的无效模型索引。 上述两个函数都使用createIndex（）工厂函数来生成索引，供其他组件使用。模型通常会向该函数提供一些唯一标识符，以确保模型索引稍后可以与其相应的项重新关联。 拖放支持和MIME类型处理模型/视图类支持拖放操作，提供了许多应用程序所需的默认行为。但是，也可以自定义项目在拖放操作期间的编码方式，默认情况下是复制还是移动数据项，以及如何将数据项插入现有模型。 此外，方便视图类（convenience view）实现了专门的行为，这些行为应该严格遵循现有开发人员的预期。“方便视图”部分提供了此行为的概述。 MIME数据默认情况下，内置模型和视图使用内部MIME类型（application/x-QAbstracteModelDataList）传递有关模型索引的信息。这将指定数据项列表的数据，其中包含每个项目的行号和列号，以及关于每个项目支持的角色的信息。 使用此MIME类型编码的数据可以通过使用包含要序列化的项的QModelIndexList调用QAbstractItemModel：：mimeData（）来获得。 在自定义模型中实现拖放支持时，可以通过重新实现以下函数以专用格式导出数据项： mimeData 此函数可以重写，以非默认application/x-qabstractemodeldatalist内部MIME类型的格式返回数据。子类可以从基类获得默认的QMimeData对象，并以其他格式向其添加数据。 对于许多模型，以MIME类型（如text/plain和image/png）表示的通用格式提供项目的内容非常有用。请注意，可以使用QMimeData：：setImageData（）、QMimeData：：setColorData（）和QMimeData：：setHtml（）函数轻松地将图像、颜色和HTML文档添加到QMimeData对象中。 接受拖放数据在视图上执行拖放操作时，将查询基础模型，以确定其支持的操作类型以及可以接受的MIME类型。此信息由qabstractemmodel：：supportedDropActions（）和qabstractemmodel：：mimeTypes（）函数提供。不重写QAbstractItemModel提供的实现的模型支持复制操作和项的默认内部MIME类型。 将序列化的项数据放到视图中时，将使用QabstractemModel：：dropMimeData（）的实现将数据插入当前模型。此功能的默认实现不会覆盖模型中的任何数据；相反，它尝试将数据项作为项的同级或子项插入。 要利用QabstractemModel对内置MIME类型的默认实现，新模型必须提供以下函数的重新实现： insertRows（） 这些函数使模型能够使用qabstractemmodel：：dropMimeData（）提供的现有实现自动插入新数据。 insertColumns（） setData 允许用项目填充新行和新列。 setItemData 此函数为填充新项提供更有效的支持。 要接受其他形式的数据，必须重新实现以下功能： supportDropActions 用于返回拖放操作的组合，指示模型接受的拖放操作类型。 mimeTypes 用于返回可由模型解码和处理的MIME类型列表。通常，支持输入到模型中的MIME类型与它在编码数据以供外部组件使用时可以使用的类型相同。 dropMimeData 对通过拖放操作传输的数据执行实际解码，确定在模型中设置数据的位置，并在必要时插入新行和新列。如何在子类中实现此功能取决于每个模型公开的数据的要求。 如果dropMimeData（）函数的实现通过插入或删除行或列来更改模型的维度，或者如果修改了数据项，则必须小心确保发出了所有的相关信号。这时候调用子类中其他函数的重新实现，如setData（）、insertRows（）和insertColumns（），就可以确保模型的行为一致。 为了确保拖动操作正常工作，必须重新实现以下从模型中删除数据的功能： removeRows（） removeRow（） removeColumns（） removeColumns（） 有关在项目视图中拖放的详细信息，请参阅在项目视图中使用拖放。 便利性视图方便视图（QListWidget、QTableWidget和QTreeWidget）覆盖了默认的拖放功能，以提供不太灵活但更自然的行为，适用于许多应用程序。例如，由于更常见的做法是将数据放入QTableWidget中的单元格，用传输的数据替换现有内容，因此模型将设置目标项的数据，而不是在模型中插入新行和列。有关在便利视图中拖放的详细信息，请参见在项目视图中使用拖放。 针对大量数据的性能优化canFetchMore（）函数检查父级是否有更多可用数据，并相应地返回true或false。函数的作用是：根据指定的父级获取数据。例如，可以在涉及增量数据的数据库查询中组合这两个功能，以填充QabstractemModel。我们重新实现canFetchMore（）以指示是否有更多数据需要提取，并根据需要使用fetchMore（）填充模型。 另一个例子是动态填充的树模型，当树模型中的一个分支展开时，我们将重新实现fetchMore（）。 如果重新实现fetchMore（）将行添加到模型中，则需要调用beginInsertRows（）和endInsertRows（）。此外，必须重新实现canFetchMore（）和fetchMore（），因为它们的默认实现返回false，并且不执行任何操作。","categories":[],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"My New Blog","slug":"My-New-Blog","date":"2022-09-07T15:50:42.000Z","updated":"2022-09-18T11:25:12.773Z","comments":true,"path":"2022/09/07/My-New-Blog/","link":"","permalink":"http://example.com/2022/09/07/My-New-Blog/","excerpt":"","text":"","categories":[],"tags":[{"name":"abc","slug":"abc","permalink":"http://example.com/tags/abc/"}]}],"categories":[],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"abc","slug":"abc","permalink":"http://example.com/tags/abc/"}]}