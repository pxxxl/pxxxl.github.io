{"meta":{"title":"Cozard 技术空间","subtitle":"规划、设计、探索","description":"Cozard 的官方博客","author":"ZYZ","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-09-19T05:03:38.000Z","updated":"2022-09-19T05:04:00.628Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-18T15:41:37.000Z","updated":"2022-09-18T15:42:24.344Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-09-18T15:40:42.000Z","updated":"2022-09-18T15:43:05.594Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Y-组合子","slug":"C++函数式编程-9-Y-组合子","date":"2022-04-14T04:48:53.000Z","updated":"2022-09-22T15:35:09.841Z","comments":true,"path":"2022/04/14/C++函数式编程-9-Y-组合子/","link":"","permalink":"http://example.com/2022/04/14/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-9-Y-%E7%BB%84%E5%90%88%E5%AD%90/","excerpt":"Y-组合子（Y-Combinator）只是一个听起来很厉害，也很难的概念，然而实践上没有什么太大价值，因为它性能较低。不过学习它能让我们更好地理解函数式编程。 Y-combinator由Haskell Brooks Curry提出，Haskell的那个Haskell，Curry的那个Curry。","text":"Y-组合子（Y-Combinator）只是一个听起来很厉害，也很难的概念，然而实践上没有什么太大价值，因为它性能较低。不过学习它能让我们更好地理解函数式编程。 Y-combinator由Haskell Brooks Curry提出，Haskell的那个Haskell，Curry的那个Curry。 不动点（fixed-point）想像一个函数G，它接收一个函数F作为参数，返回另一个函数。 如果满足F = G（F）则称F为G的不动点 如果F是G的不动点，那么：F = G（F）=G（G（F））=G（G（G（F）））= …… 匿名递归想象一个匿名函数（为了方便称呼，给它名字M），它接收一个函数f，然后在其函数体内调用f。 在此基础上，如果这样定义一个函数：Func = M（Func）； 这样Func将成为递归函数，因为： 12345Func（）//相当于M（Func）（）//M在函数体内调用Func，于是相当于Func（） 无限递归。 然而如果在M的函数体内加上递归终止条件与迭代条件，Func就能成为一个真正的递归函数。 1234567//伪代码auto M = [](接收int a返回int b的函数)&#123; return a == 0 ? 1 : 函数(a - 1);&#125;Func&lt;int(int)&gt; = M(Func);//Func是阶乘递归 成功用M构造了递归。注意看M的表达式，当M返回函数的时候： Func = M（Func）； Func成为了M的不动点，同时Func自己是递归函数。 显然，如果需要写一个匿名递归函数，M部分是能很快写出来的，因为M知道递归函数的名字Func，M可以在自己的函数体里面写Func的递归逻辑，就像在Func的函数体里一样。 难点在已知M的情况下找出Func，是否能找到这样一个具有普遍性的函数，它接收M，返回Func？ 数学推导格式规定规则一： 规则二： 举例：化简式子 可以看到，左边括号里是一个函数，用7来调用它，得 可以看到，左边括号里是一个函数，用2来调用它，得 很好，现在你已经掌握这套推导规则了，现在让我们引入Y-组合子吧！ Y-组合子Haskell Curry找到了一个函数 Y-组合子，它的形式是这样的： 它有这样的性质：（F是函数） 即Y（F）是 F 的不动点 下面开始数学证明： //注意了要把当成一个整体来调用函数了 证毕。 利用Y-组合子实现匿名递归比照前面的几个式子： 其中Func是递归函数。 不妨令 Y（F）= Func ，M = F，上述公式完全成立 代换，得： 成功了。 C++实现Y-组合子代码如下 1234567891011auto Y = [](auto&amp;&amp; f)&#123; return [&amp;f](auto&amp;&amp; x)&#123; return f([&amp;x](auto&amp;&amp; y)&#123; return x(x)(y); &#125;); &#125;[&amp;f](auto&amp;&amp; x)&#123; return f([&amp;x](auto&amp;&amp; y)&#123; return x(x)(y); &#125;); &#125;;&#125;; 来使用一下 1234567auto M = [](auto&amp;&amp; f)&#123; return [](int n)&#123; n == 0 ? 1 : f(n); &#125;;&#125;;auto factorial = compose(Y, M); 这样就完成了匿名递归函数的编写。 对了还有个可优化的点，还记得我们之前说过的柯里化吗，既然Y组合子每次使用时都要和M函数结合，为什么我们不把Y组合子直接固定在compose里呢？ 123auto rec = curry(compose)(Y);auto factorial = rec(M); 简洁，优雅，这便是函数式编程的魅力。 这时候你可能已筋疲力竭，不禁会想，弄这个开销巨大，对于递归编写又没多少简化的东西干什么呢？我想说的是，编程不仅仅是枯燥乏味的增删改查—— 一轮精妙的推导，一节优美的实现，一段如诗的代码，才是程序员的浪漫与追求。","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"操作容器","slug":"C++函数式编程-8-操作容器","date":"2022-04-14T04:47:55.000Z","updated":"2022-09-22T15:35:07.200Z","comments":true,"path":"2022/04/14/C++函数式编程-8-操作容器/","link":"","permalink":"http://example.com/2022/04/14/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-8-%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8/","excerpt":"在函数式编程中，变量是不可变的，当产生一个新值时，我们创造一个新变量来“代表”它，而不是“修改”现有的变量。 对于容器也是一样，对容器的操作不会改变现有容器里的值以及容器本身，而是产生一个新的容器，里面装着新的值。","text":"在函数式编程中，变量是不可变的，当产生一个新值时，我们创造一个新变量来“代表”它，而不是“修改”现有的变量。 对于容器也是一样，对容器的操作不会改变现有容器里的值以及容器本身，而是产生一个新的容器，里面装着新的值。 可以使用C++标准库自带的**std::vector(C++11)**作为容器，也可以自己写一个。 这里把vector重新命个名，叫seq。 12template&lt;typename T = int&gt;using seq = std::vector&lt;T&gt;; 操作容器与命令式编程不同，函数式编程操作容器往往不是靠下标，而是用一组可复用的函数和功能函数进行组合来整体操作容器。 有点绕口，来直接看实例。 map将容器中的每个值用传入的函数映射成新的值，然后装入新的容器中，看例子。 123456789std::vector&lt;int&gt; vec&#123;1, 2, 3, 4, 5&#125;;auto increase = [](int a)&#123; return a + 1;&#125;;auto new_vec = map(vec, increase);//new_vec : &#123;2, 3, 4, 5, 6&#125; 下面是针对std::vector的map的一种实现（C++11），你也可以实现自己的版本 12345678template&lt;typename T, typename F&gt;constexpr auto map(seq&lt;T&gt; vec, F&amp;&amp; f) &#123; seq new_vec = vec; for (unsigned i = 0; i &lt; my_array.size(); i++) &#123; new_vec[i] = std::forward&lt;F&gt;(f)(new_vec[i]); &#125; return new_vec;&#125; filter将容器中满足某个条件的值复制到新的容器中，看例子。 123456789std::array&lt;int&gt; my_array&#123;1, 2, 3, 4, 5&#125;;auto judge = [](int a)&#123; return a &gt; 3;&#125;;auto new_array = filter(my_array, judge);//new_array : &#123;4, 5&#125; 下面是针对std::vector的filter的一种实现（C++11），你也可以实现自己的版本 12345678910template&lt;typename T, typename F&gt;constexpr auto filter(std::seq&lt;T&gt; vec, F&amp;&amp; f) &#123; std::seq&lt;T&gt; n_vec; for (auto value : vec) &#123; if (f(value)) &#123; n_vec.push_back(std::move(value)); &#125; &#125; return n_vec;&#125; reduce这个用图片更易理解 reduce接收三个参数，第一个是列表，第二个是接收两个参数的函数，第三个是初始值，返回一个值。 来实现reduce 123456789101112template&lt;typename T, typename F, typename Init&gt;constexpr auto reduce(seq&lt;T&gt; vec, F&amp;&amp; f, Init&amp;&amp; init) &#123; std::decay_t&lt;Init&gt; v; v = init; constexpr if (vec.size() == 0) &#123; return v &#125; for (auto&amp; value : vec ) &#123; v = f(v, value); &#125; return v;&#125;","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"函子","slug":"C++函数式编程-7-函子","date":"2022-04-14T04:46:34.000Z","updated":"2022-09-22T16:13:28.589Z","comments":true,"path":"2022/04/14/C++函数式编程-7-函子/","link":"","permalink":"http://example.com/2022/04/14/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-7-%E5%87%BD%E5%AD%90/","excerpt":"从本节开始，我们就要接触“容器”了。在大多数情况下，函数式编程是操作放在“容器”中的数据而不是操作裸数据。让我们从最简单的容器——functor开始吧。 Functor（函子）定义： 函子必须是一个容器 函子必须有map方法，（map：接收一个函数，map用functor里的值调用这个函数，然后根据返回值构造一个新的函子。）","text":"从本节开始，我们就要接触“容器”了。在大多数情况下，函数式编程是操作放在“容器”中的数据而不是操作裸数据。让我们从最简单的容器——functor开始吧。 Functor（函子）定义： 函子必须是一个容器 函子必须有map方法，（map：接收一个函数，map用functor里的值调用这个函数，然后根据返回值构造一个新的函子。） 来实现一个最简单的函子吧 1234567891011121314151617#include&lt;functional&gt;template&lt;typename T&gt;class functor_t &#123; T t;public: functor_t(T v) &#123; t = v; &#125; auto map(std::function&lt;T(T)&gt;&amp;&amp; mapping) &#123; return functor_t&lt;T&gt;(std::forward&lt;std::function&lt;T(T)&gt;&gt;(mapping)(t)); &#125;&#125;;template&lt;typename T&gt;constexpr functor_t&lt;std::decay_t&lt;T&gt;&gt; functor_of(T&amp;&amp; t) &#123; return &#123; std::forward&lt;T&gt;(t) &#125;;&#125;//约定俗成，functor应该有一个叫做of的方法来构建一个functor 函数式编程里的计算大多是操作函子而不是操作函子里的值。 123456789auto functorA = functor(2);auto add_3 = curry(add)(3);auto multiply_5 = curry(multiply)(5);auto mod_2 = curry(mod)(2);auto print = [](auto&amp;&amp; a)&#123;std::cout&lt;&lt;a;return a;&#125;auto processed = functorA.map(add_3).map(multiply_5).map(mod_2).map(is_even).map(print); 函子还可以连续调用，来看下面例子。 123456auto num = functor_of(1);auto num_is_even = num.map(is_even);//num_is_even同样是一个functornum.map 在函子的基础上添加某些特性可以构造特殊的函子。 Maybemaybe是特殊的函子，它具有函子的所有特征，此外，它实现了“空值过滤”的功能。 它的map具有一种特点，如果maybe里的值是一个“空值”，那么map就会直接将maybe拷贝一份作为返回值，而不会尝试拿“空值”来调用传入的函数（如果调用了，可能会产生错误）。 来实现一下吧。 Applicativeapplicative是特殊的函子，它具有函子的所有特征，此外，它实现了“apply”的功能。 如果一个applicative里装着值，另一个applicative里装着接收这个值的函数，装着值的applicative就可以apply另一个applicative，利用函数的返回值创建一个新的applicative。 Monad（单子）monad是特殊的函子，它具有函子的所有特征，此外，它实现了“flatmap”的功能。 有时处理函子时会出现“函子嵌套”，就是说函子内部储存的值也是一个函子。而monad的flatmap保证函子内部储存的值一定不是函子。（flatmap好比将嵌套的函子“拍平”） 来实现一下 更美观的书写方式C++20的range库使用了类似Unix的“管道运算符”，可以让函子（以及一些容器）的函数调用变得极其优美。首先，我们需要重载functor的 | 运算符。 1234567891011121314151617181920#include&lt;functional&gt;template&lt;typename T&gt;class functor_t &#123; T t;public: functor_t(T v) &#123; t = v; &#125; auto map(std::function&lt;T(T)&gt;&amp;&amp; mapping) &#123; return functor_t&lt;T&gt;(std::forward&lt;std::function&lt;T(T)&gt;&gt;(mapping)(t)); &#125; auto operator|(std::function&lt;T(T)&gt;&amp;&amp; mapping) &#123; return functor_t&lt;T&gt;(std::forward&lt;std::function&lt;T(T)&gt;&gt;(mapping)(t)); &#125; &#125;;template&lt;typename T&gt;constexpr functor_t&lt;std::decay_t&lt;T&gt;&gt; functor_of(T&amp;&amp; t) &#123; return &#123; std::forward&lt;T&gt;(t) &#125;;&#125; 本质是map改了个名字，但是调用效果非常棒。 改写本章开头functor演示的代码。 12345678auto processed = functorA |add_3 |multiply_5 |mod_2 |is_even |print ; 好看吧，这种写法清晰明朗，比一长条的map要易读。而且这种写法也符合无参风格（point-free），是函数式编程所提倡的！ 接下来一章，我们将学习C++的range库，深入了解一下C++特色的函数式编程。","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"小结一下","slug":"C++函数式编程-6-小结一下","date":"2022-04-14T04:45:51.000Z","updated":"2022-09-22T15:35:01.435Z","comments":true,"path":"2022/04/14/C++函数式编程-6-小结一下/","link":"","permalink":"http://example.com/2022/04/14/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-6-%E5%B0%8F%E7%BB%93%E4%B8%80%E4%B8%8B/","excerpt":"在前面的章节中，我们已经初步学习了函数式编程的基本思维以及概念，下面来梳理一下： 函数式编程将函数作为一等公民 函数式编程是声明式的 函数式编程要求不要改变变量的值","text":"在前面的章节中，我们已经初步学习了函数式编程的基本思维以及概念，下面来梳理一下： 函数式编程将函数作为一等公民 函数式编程是声明式的 函数式编程要求不要改变变量的值 尽量编写纯函数 使用组合函数将纯函数组合起来 使用std::function实现lambda的递归 使用组合函数时可以无视被组合函数的中间参数，这种风格叫做Point-Free 使用偏函数与柯里化减少函数的参数，最好降低至一个 在接下来的章节中，我们将要接触到“容器”以及对容器的操作。很多时候我们并不处理裸露在外面的值，而是处理被包裹在容器中的值。 我们还将接触到一些有趣的数学推导，见证Y-组合子是如何帮助我们实现匿名递归的。 C++20对于Range的支持与管道运算符 对容器的操作 函子Functor以及衍生 Y-组合子与递归 我准备了一些题目，尝试着用函数式编程的思维解决他们。这些题目有助于加深你对函数式编程的理解。","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"偏函数和柯里化","slug":"C++函数式编程-5-偏函数和柯里化","date":"2022-04-14T04:44:17.000Z","updated":"2022-09-22T15:34:58.442Z","comments":true,"path":"2022/04/14/C++函数式编程-5-偏函数和柯里化/","link":"","permalink":"http://example.com/2022/04/14/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-5-%E5%81%8F%E5%87%BD%E6%95%B0%E5%92%8C%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"函数式编程特别重视一元函数 Partial（偏函数）“偏函数”指：固定某个参数为特定值，然后返回一个接收余下参数的函数。这是一种减少参数的方式。 打个比方：我们已经有了greater函数，它接收两个参数a和b。","text":"函数式编程特别重视一元函数 Partial（偏函数）“偏函数”指：固定某个参数为特定值，然后返回一个接收余下参数的函数。这是一种减少参数的方式。 打个比方：我们已经有了greater函数，它接收两个参数a和b。 如果我想编写一个greater_than_6函数，就可以基于已有的greater函数，将参数b固定为6，这样，得到的新函数greater_than_6只接收一个参数。 来写一下partial 12345template&lt;class _Fx, class... Args&gt;constexpr auto partial(_Fx&amp;&amp; f, Args&amp;&amp;... args)&#123; return std::bind_front(f, std::forward&lt;Args&gt;(args)...);&#125; 写完了，C++20及以上适用。 也可以用C++标准库（C++11）提供的std::bind来固定参数： 1234567#include&lt;functional&gt;using namespace std::placeholders;auto more_than_6 = std::bind(more, _1, 6);more_than_6(1); //false 以下是bind用法的归纳： 123456789101112131415161718192021222324252627282930313233#include&lt;functional&gt;using namespace std::placeholders;//占位符被定义在这个名字空间里//std::bind接收 n+1 个参数，其中n是函数参数的个数//std::bind的第一个参数是函数名，后面的参数要么是具体的值，要么是占位符//占位符类似这种：_1, _2, _3,......//占位符表示 “生成的新函数的第n个参数” 将会被放在原函数的占位符位置。来看演示auto less_than_6 = std::bind(more, 6, _1);//看，一共只有一个占位符，这意味着新函数一共只会有一个参数//调用这个新函数时，这个参数会被放进对应占位符的位置less_than_6(10);//bind的顺序是(6, _1), 10被放进_1//所以相当于调用：more(6, 10);//来来来我们再比较一下std::bind(more, 6, _1); less_than_6(10); more(6, 10);//我想你已经大概明白了，来看看复杂的auto less = std::bind(more, _2, _1);//这次有两个占位符less(6, 10);//6被放进占位符_1 ,因为它是新函数的第一个参数//10被放进占位符_2 ,因为它是新函数的第二个参数//bind的顺序是(_2, _1)//所以等效于调用：more(10, 6); Curry（柯里化）柯里化是特殊的Partial（偏函数）。 它并不固定任何一个参数，被柯里化的函数有这样的行为： 只接收一个或多个参数并固定它，返回一个被柯里化的接收剩余参数的函数 当所有参数都被固定时返回结果 概念有点绕，来看演示： 12345678910111213141516//函数名curryauto sum_of_three = [](auto a, auto b, auto c)&#123; return a + b + c;&#125;auto curried = curry(sum_of_three);//以下的调用法等效sum_of_three(1, 2, 3); //6curried_sum_of_three(1)(2)(3); //6//理解柯里化函数的调用法auto curried_sum_1 = curried(1);auto curried_sum_2 = curried_sum_1(2);auto curried_sum_3 = curried_sum_2(3); //6 标准库中没有这样的函数，我们来自己写一个： （利用C++20的concept弄的，早些版本的写法不熟练） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778template&lt;class F&gt;struct curry_t &#123; F f; template&lt;class... Args&gt; requires (std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)&amp; noexcept(noexcept(std::invoke(f, std::forward&lt;Args&gt;(args)...))) -&gt;decltype(std::invoke(f, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; requires (!std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)&amp; noexcept(noexcept(curry(partial(f, std::forward&lt;Args&gt;(args)...)))) -&gt;decltype(curry(partial(f, std::forward&lt;Args&gt;(args)...))) &#123; return curry(partial(f, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; requires (std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)&amp;&amp; noexcept(noexcept(std::invoke(f, std::forward&lt;Args&gt;(args)...))) -&gt;decltype(std::invoke(f, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; requires (!std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)&amp;&amp; noexcept(noexcept(curry(partial(f, std::forward&lt;Args&gt;(args)...)))) -&gt;decltype(curry(partial(f, std::forward&lt;Args&gt;(args)...))) &#123; return curry(partial(f, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; requires (std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)const &amp; noexcept(noexcept(std::invoke(f, std::forward&lt;Args&gt;(args)...))) -&gt;decltype(std::invoke(f, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; requires (!std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)const &amp; noexcept(noexcept(curry(partial(f, std::forward&lt;Args&gt;(args)...)))) -&gt;decltype(curry(partial(f, std::forward&lt;Args&gt;(args)...))) &#123; return curry(partial(f, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; requires (std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)const &amp;&amp; noexcept(noexcept(std::invoke(f, std::forward&lt;Args&gt;(args)...))) -&gt;decltype(std::invoke(f, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; requires (!std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)const &amp;&amp; noexcept(noexcept(curry(partial(f, std::forward&lt;Args&gt;(args)...)))) -&gt;decltype(curry(partial(f, std::forward&lt;Args&gt;(args)...))) &#123; return curry(partial(f, std::forward&lt;Args&gt;(args)...)); &#125;&#125;;export template&lt;class F&gt;constexpr curry_t&lt;std::decay_t&lt;F&gt;&gt; curry(F&amp;&amp; f)&#123; return &#123; std::forward&lt;F&gt;(f) &#125;;&#125; 另外说一下，纯粹的curry严格地让函数一次只接收一个参数，而上面的curry要求更宽松，你可以一次传几个参数进去。","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"胶水","slug":"C++函数式编程-4-胶水","date":"2022-04-14T04:39:56.000Z","updated":"2022-09-22T15:34:43.283Z","comments":true,"path":"2022/04/14/C++函数式编程-4-胶水/","link":"","permalink":"http://example.com/2022/04/14/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-4-%E8%83%B6%E6%B0%B4/","excerpt":"已经编写了一些小型函数，我们来看看它们可以如何变化与组合 记住法则一：函数是一等公民。","text":"已经编写了一些小型函数，我们来看看它们可以如何变化与组合 记住法则一：函数是一等公民。 函数否定 希望编写一个函数，它接收另一个函数，返回这个函数的否定函数。 C++17标准库提供了这个函数：std::not_fn （接收一个返回bool类型的函数，返回一个反转原函数返回值的新函数） 来试一下： 1234567auto is_odd = [](auto a)&#123; return a % 2;&#125;;auto is_even = std::not_fn(is_odd);//判断奇偶的函数//其中判断偶的函数没有直接编写，而是从判断奇的函数中直接生成 把函数当作参数，“函数式编程”是不是有点意思了？再来看这个： 12345auto not_equ = std::not_fn(eq);//从 “等于” 函数中直接生成 “不等于” 函数not_equ(1, 2); //trueeq(1, 2); //false 函数或，函数与有了逻辑非，怎能没有逻辑或和逻辑与呢？但很遗憾，标准库没有提供。 怕什么，学C++的最会造轮子了！来写一下试试。 （注：若看不懂，建议复制粘贴直接用，这部分的语法我将在“模板元编程”部分讲解。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//函数逻辑或#include&lt;functional&gt;template&lt;class F1, class F2&gt;struct or_fn_t &#123; F1 f1; F2 f2; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args)const &amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp;&amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const &amp;&amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125;&#125;;template&lt;class F1, class F2&gt;constexpr or_fn_t&lt;std::decay_t&lt;F1&gt;, std::decay_t&lt;F2&gt;&gt; or_fn(F1&amp;&amp; f1, F2&amp;&amp; f2)&#123; return &#123; std::forward&lt;F1&gt;(f1), std::forward&lt;F2&gt;(f2) &#125;;&#125;//函数逻辑与template&lt;class F1, class F2&gt;struct and_fn_t &#123; F1 f1; F2 f2; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args)const&amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp;&amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const&amp;&amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125;&#125;;template&lt;class F1, class F2&gt;constexpr and_fn_t&lt;std::decay_t&lt;F1&gt;, std::decay_t&lt;F2&gt;&gt; and_fn(F1&amp;&amp; f1, F2&amp;&amp; f2)&#123; return &#123; std::forward&lt;F1&gt;(f1), std::forward&lt;F2&gt;(f2) &#125;;&#125; 现在有两个函数 or_fn 和 and_fn。 (接收两个参数完全相同且返回bool类型的函数，返回经过逻辑组合的新函数） 来用一下试试： 1234567891011auto eq_less = or_fn(eq, less);//“小于”和“等于”通过 逻辑或 生成“小于等于”auto greater = not_fn(eq_less);//否定 “小于等于” 来生成 “大于”auto eq_greater = or_fn(eq, greater);//简单粗暴的 “或” 组合eq_greater(1, 2); //falsegreater(2, 1); //true 现在，你体会到函数式编程所说的“函数是一等公民”了吗？ 凭借类似于“胶水”的组合函数，我们能像变量一样操纵、组合与生成新函数。 函数组合数学中有“复合函数”这一概念。复合函数将前一个函数的输出用作下一个函数的输入，来看几张图： （图引用自https://zhuanlan.zhihu.com/p/74777206） 命令式编程存在一系列中间变量 函数式编程 函数组合 在函数式编程中我们称此为“函数组合”（compose），函数组合是生成新函数的重要途径。 C++标准库没有“函数组合”函数，所以又到了喜闻乐见的造轮子时间~ （注：若看不懂，建议复制粘贴直接用，这部分的语法我将在“模板元编程”部分讲解。） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//函数组合，从右往左执行template&lt;class F1, class F2&gt;struct compose_t &#123; F1 f1; F2 f2; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp; noexcept(noexcept(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const &amp; noexcept(noexcept(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp;&amp; noexcept(noexcept(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const &amp;&amp; noexcept(noexcept(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)); &#125;&#125;;template&lt;class F1, class F2&gt;constexpr compose_t&lt;std::decay_t&lt;F1&gt;, std::decay_t&lt;F2&gt;&gt; compose(F1&amp;&amp; f1, F2&amp;&amp; f2)&#123; return &#123; std::forward&lt;F1&gt;(f1), std::forward&lt;F2&gt;(f2) &#125;;&#125;template&lt;class F1, class F2, class... Args&gt;constexpr compose_t&lt;std::decay_t&lt;F1&gt;, std::decay_t&lt;compose_t&lt;F2, Args...&gt;&gt;&gt; compose(F1&amp;&amp; f1, F2&amp;&amp; f2, Args&amp;&amp;... args)&#123; return &#123; std::forward&lt;F1&gt;(f1), std::forward&lt;compose_t&lt;F2, Args...&gt;&gt;(compose(f2, args)) &#125;;&#125;//函数组合，从左往右执行template&lt;class F1, class F2&gt;struct pipe_t &#123; F1 f1; F2 f2; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp; noexcept(noexcept(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const&amp; noexcept(noexcept(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp;&amp; noexcept(noexcept(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const&amp;&amp; noexcept(noexcept(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)); &#125;&#125;;template&lt;class F1, class F2&gt;constexpr pipe_t&lt;std::decay_t&lt;F1&gt;, std::decay_t&lt;F2&gt;&gt; pipe(F1&amp;&amp; f1, F2&amp;&amp; f2)&#123; return &#123; std::forward&lt;F1&gt;(f1), std::forward&lt;F2&gt;(f2) &#125;;&#125;template&lt;class... Args, class F1, class F2&gt;constexpr pipe_t&lt;std::decay_t&lt;pipe_t&lt;Args..., F1&gt;&gt;,std::decay_t&lt;F2&gt;&gt; pipe(Args&amp;&amp;... args, F1&amp;&amp; f1, F2&amp;&amp; f2)&#123; return &#123; std::forward&lt;pipe_t&lt;Args..., F1&gt;&gt;(pipe(f2, args)) ,std::forward&lt;F2&gt;(f2) &#125;;&#125; 现在有了两个函数compose和pipe 演示一下用法： 12345678910111213141516//compose和pipe接收任意个数的函数，返回经过组合的函数//其中compose是从右向左组合，pipe是从左向右组合auto sum_is_odd = compose(is_odd, sum);sum_is_odd(1, 3);//相当于调用is_odd(sum(1, 3));//结果是falseauto mul_is_odd = pipe(mul, is_odd);mul_is_odd(1, 3);//相当于调用is_odd(mul(1, 3));//结果是true 有了compose和pipe，我们能将一系列过程看作一个整体，从而忽略复杂的中间量，简化代码。 此外，注意到如果函数只接收一个参数，我们就有机会连续组合多个函数 12345678auto add_1 = [](int a)&#123; return a + 1;&#125;;auto add_4 = compose(add_1, add_1, add_1, add_1);//只是举个例子，不必纠结实用性add_4(1); //5 我们目前编写的大多数函数是多参数函数，在下一节我们来看看如何将多参数函数转化为单参数函数。","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"积木","slug":"C++函数式编程-3-积木","date":"2022-04-14T04:38:07.000Z","updated":"2022-09-22T15:34:45.911Z","comments":true,"path":"2022/04/14/C++函数式编程-3-积木/","link":"","permalink":"http://example.com/2022/04/14/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-3-%E7%A7%AF%E6%9C%A8/","excerpt":"下面我们来趁热打铁，编写一些简单的纯函数来练练手，逐渐熟悉函数式编程的思维方式。 打开你的编辑器，和我一起写 这些纯函数将会在之后的学习中用到","text":"下面我们来趁热打铁，编写一些简单的纯函数来练练手，逐渐熟悉函数式编程的思维方式。 打开你的编辑器，和我一起写 这些纯函数将会在之后的学习中用到 包装个简单的算数操作试试12345678910111213141516171819auto sum = [](auto a, auto b)&#123; return a + b;&#125;;auto sub = [](auto a, auto b)&#123; return a - b;&#125;;auto mul = [](auto a, auto b)&#123; return a * b;&#125;;auto divi = [](auto a, auto b)&#123; return a / b;&#125;;auto mod = [](auto a, auto b)&#123; return a % b;&#125;; 看上去没什么用，然而这种高度抽象的简单函数正是复杂函数的基础。 接下来编写逻辑函数与比较函数1234567891011121314151617181920212223auto not_ = [](bool a)&#123; return !a;&#125;;auto and_ = [](bool a, bool b)&#123; return a &amp;&amp; b;&#125;;auto or_ = [](bool a, bool b)&#123; return a || b;&#125;;auto xor_ = [](bool a, bool b)&#123; return (!a&amp;&amp;b)||(!b&amp;&amp;a);&#125;;auto less = [](auto a, auto b) &#123; return a &lt; b;&#125;;auto eq = [](auto a, auto b) &#123; return a == b;&#125;; 函数式编程有点像搭积木，我们先造好一些小型积木，到后面再看看它们能组合出什么好玩的大家伙来。","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"开启新世界的大门","slug":"C++函数式编程-2-开启新世界的大门","date":"2022-04-13T16:11:00.000Z","updated":"2022-09-22T15:35:25.321Z","comments":true,"path":"2022/04/14/C++函数式编程-2-开启新世界的大门/","link":"","permalink":"http://example.com/2022/04/14/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-2-%E5%BC%80%E5%90%AF%E6%96%B0%E4%B8%96%E7%95%8C%E7%9A%84%E5%A4%A7%E9%97%A8/","excerpt":"函数式编程无论是面向过程还是面向对象，都是一种“指令式编程”模式：程序员“告诉”机器怎么做事，把事情的解决方案一步步列出来。 与“指令式编程”对应的是“声明式编程”：程序员把重心放在“做什么”而不是“怎么做”。打个比方：使用数据库语言SQL时，用户是不必操心机器是怎么插入或者查找数据的，只需要一句声明“我要做什么”，机器便会自动寻找解决方案；此外，一些逻辑编程语言，也是“声明式”的。 函数式编程偏向于“声明式编程”而不是“指令式编程”。","text":"函数式编程无论是面向过程还是面向对象，都是一种“指令式编程”模式：程序员“告诉”机器怎么做事，把事情的解决方案一步步列出来。 与“指令式编程”对应的是“声明式编程”：程序员把重心放在“做什么”而不是“怎么做”。打个比方：使用数据库语言SQL时，用户是不必操心机器是怎么插入或者查找数据的，只需要一句声明“我要做什么”，机器便会自动寻找解决方案；此外，一些逻辑编程语言，也是“声明式”的。 函数式编程偏向于“声明式编程”而不是“指令式编程”。 万事开头难，学习函数式编程将是一段难忘的旅途，途中可能会有各种挫折，但请不要放弃，毕竟你连C++的基本语法都啃下来了，还有什么东西是学不会的呢？ 函数式编程的优点1. 可读性强函数式编程的“声明式”特征意味着程序员将更多关注某个代码片段的“作用”而不是“实现细节”，其代码相较于其他编程范式具有较强的可读性。 需要注意的一点是，对于刚入门函数式编程的新手，函数式编程的一些概念很陌生难懂。出现这种情况的原因并不是因为函数式编程本身“难于阅读”，而仅仅是因为“不熟悉”。打个比方，C语言初学者对数组下标以0开始的迷惑，难道也是。 因此，想要体会到函数式编程的“强可读性”，前提就是要多多练习，熟悉函数式编程风格与思路。 2. 高强度复用函数式编程代码抽象程度很高，粒度比较低，复用非常方便。 很多时候并不直接编写很大的函数，而是将小函数拼接组合，像用胶水粘合积木一样。显然，胶水能复用，部分积木也能复用。 实际编程中常用compose组合函数，curry柯里函数，not_fn取反函数。它们是高度抽象可复用函数的典范。 3. 适合高并发现代微处理器晶体管数目增长放缓，而核心数增长加快，这意味着可并发的程序越来越有性能优势。 一般的指令式程序需要耗费一部分时间资源在线程/进程交互上面。而函数式编程因为没有中间状态，变量不可更改等特征，可以轻易支持高并发。 使用C++进行函数式编程Haskell、Scala、JavaScript 等语言以函数式编程闻名，C++作为现代语言特性的“究极缝合怪”也紧紧跟上了时代的脚步。自C++11开始，C++陆续添加了不少好用的新特性用以支持函数式编程： auto类型推导 lambda表达式 std::function函数包装器 std::bind工具 等等还有很多，我会在需要时一一阐述。 原教旨主义（原教旨主义：最严格的函数式编程要求） 鉴于你现在对函数式编程的印象可能是很抽象的，下面我向你灌输几个概念，以使你迅速适应函数式编程的思维方式。 。 。 。 准备好哦~ 。 。 。 开始！ 法则零：函数是 数据的“映射”而不是“操作”的集合在面向过程编程语言里，函数（function）是一组代码（或者说操作）的集合，现在，请你忘掉它们，回想起在数学中函数是如何定义的。 函数为两集合间的一种对应关系：输入值集合中的每项元素皆能对应唯一一项输出值集合中的元素。 “函数式编程”中的函数是数学意义上的函数。“函数”应该具有以下特点： 引用透明：函数的输出只依赖输入的值，与外界其他量没有任何关系。 无副作用：函数调用不会产生除运算之外其他效果，同一组数据永远得到相同的值。 我们称拥有这些特点的函数为 纯函数 。 法则一：函数是一等公民函数可以和变量一样，可以赋值给其他变量，也可以作为参数，传入一个函数，或者作为别的函数的返回值。 法则二：变量不可修改函数式编程认为“状态量”是导致程序复杂难以分析的根源。程序在不同运行时刻具有不同的“状态”（比如说循环语句的计数变量、累加过程中的计数变量等等），这些状态量时常变化，使程序的复杂度大大增加。 因此，在函数式编程中，你应尽量不要修改变量，这意味着： 不要使用循环语句（应该使用递归）。 函数应当返回一个新变量而不是在原有变量上做修改（函数即是映射）。 法则三：使用表达式而不是语句：表达式是一段单纯的运算过程，总是有返回值，而语句是执行某种操作，没有返回值。 函数式编程中的每一步都是单纯的运算，而且都有返回值。 完毕。 以上勾勒了函数式编程的轮廓，不理解也没关系，继续下面的章节，在实践中慢慢体会函数式编程的魅力。","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"lambda 表达式","slug":"C++函数式编程-1-lambda 表达式","date":"2022-04-13T16:10:57.000Z","updated":"2022-09-22T15:34:31.390Z","comments":true,"path":"2022/04/14/C++函数式编程-1-lambda 表达式/","link":"","permalink":"http://example.com/2022/04/14/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-1-lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"熟悉一下C++函数式编程的主角：lambda表达式。 请将你的编译器版本调到C++17及以上。 定义一个labmda变量（C++11与C++14）labmda既是一个函数，也是一个变量（事实上，它是一个由编译器自动生成的可调用类），让我们先来看看labmda是什么样子的：","text":"熟悉一下C++函数式编程的主角：lambda表达式。 请将你的编译器版本调到C++17及以上。 定义一个labmda变量（C++11与C++14）labmda既是一个函数，也是一个变量（事实上，它是一个由编译器自动生成的可调用类），让我们先来看看labmda是什么样子的： 1234567891011121314151617181920212223242526272829303132333435[]()&#123;&#125;//此即为labmda的基本结构//记住labmda既是一个函数，也是一个变量auto func1 = []()&#123;&#125;;//一般使用自动类型推导来定义labmda变量，因为通常labmda表达式的类型名很长//现在我们拥有了一个叫func1的labmda表达式变量auto func2 = [](int a)&#123;&#125;//我们的func2现在可以接受一个int类型的变量作为参数//但是它什么都不做auto func3 = [](int a)&#123; std::cout&lt;&lt;a; return;&#125;//func3拥有了函数体，它打印传入的int类型的变量//记住labmda既是一个函数，也是一个变量auto func4 = [](int a)&#123; std::cout&lt;&lt;a; return a+1;&#125;//func4拥有了返回值//注意：可以不声明返回值类型，编译器会自己推导（C++14）//如果需要声明返回值，就这样写（C++11）：auto func5 = [](int a)-&gt;int&#123; std::cout&lt;&lt;a; return a+1;&#125; 现在，labmda已经拥有了一个函数所应该拥有的一切： 传入参数 函数体 返回值 名字 下面来使用它。 使用labmda变量（C++11）1234567auto func = [](int a)-&gt;int&#123; std::cout&lt;&lt;a; return a+1;&#125;int num = func(1);//可以将lambda表达式视为一个函数，像使用函数一样使用它。 接下来，我们来看看labmda的捕获列表。 捕获列表（C++11）lambda表达式可以“捕获”目前所处位置可见的变量，然后在函数体里面操作这些变量。 来看例子： 123456789int main()&#123; int message = 17; auto func = [message](int a)&#123; return a + message; &#125;; std::cout&lt;&lt;func(1);&#125;//输出18 将需要捕获的变量写进方括号，即可在函数体里面操作这个变量。（如果你在lambda函数体内使用了某个外部的局部变量又没有捕获，编译器会报错的。） 有两种捕获方式： 值捕获：相当于把外部变量复制一份放进lambda函数体里。 引用捕获：相当于创建外部变量的引用放进lambda函数体里，在lambda函数体里修改这个变量将影响到对应外部变量的值。 来看例子： 12345678910111213141516int var1 = 1;int var2 = 2;int var3 = 3;auto func1 = [var1]()&#123;&#125;;//这是默认情况，值捕获auto func1 = [var1, var2]()&#123;&#125;;//这是默认情况，值捕获，而且捕获了两个变量。auto func2 = [&amp;var1]()&#123;&#125;;//这是引用捕获auto func3 = [=]()&#123;&#125;;//对所有变量进行值捕获auto func4 = [&amp;]()&#123;&#125;;//对所有变量进行引用捕获auto func5 = [=,&amp;var2]()&#123;&#125;;//var2进行引用捕获，其他所有变量进行值捕获 基本语法就是这样，实际使用时可以自己类推。 （到这里你可能觉得捕获列表没啥用。我可以理解，你现在只需要简单了解一下，待会儿正式使用时你会惊叹它的威力的。） lambda参数自动类型推导（C++14）C++14允许lambda表达式的参数类型是“auto”，编译器将在编译时自动推导其类型。 好，这样我们就学完lambda表达式的基本功能了。现在，让我们迈入函数式编程的旅途吧！","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"auto发展史","slug":"现代C++-1-auto发展史","date":"2022-04-13T15:59:06.000Z","updated":"2022-09-22T15:36:03.433Z","comments":true,"path":"2022/04/13/现代C++-1-auto发展史/","link":"","permalink":"http://example.com/2022/04/13/%E7%8E%B0%E4%BB%A3C++-1-auto%E5%8F%91%E5%B1%95%E5%8F%B2/","excerpt":"","text":"autoC++11 用auto在函数体内定义变量 auto声明普通函数返回值，接尾置返回值类型 decltype(auto)超级推导 C++14 自动推导auto声明的函数返回值 lambda参数可以是auto C++17 结构化绑定 C++20 concept 的一种声明方式","categories":[{"name":"现代C++","slug":"现代C","permalink":"http://example.com/categories/%E7%8E%B0%E4%BB%A3C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"lambda发展史","slug":"现代C++-6-constexpr发展史","date":"2022-04-13T15:59:06.000Z","updated":"2022-09-22T15:46:30.543Z","comments":true,"path":"2022/04/13/现代C++-6-constexpr发展史/","link":"","permalink":"http://example.com/2022/04/13/%E7%8E%B0%E4%BB%A3C++-6-constexpr%E5%8F%91%E5%B1%95%E5%8F%B2/","excerpt":"","text":"constexpr在C++11进入标准，指代编译期即确定的表达式。 C++11 constexpr可修饰字面类型（包括拥有平凡析构以及constexpr构造的类类型） constexpr修饰变量自动const constexpr函数只能包含一个语句：return constexpr声明函数自动inline C++14 constexpr函数内可以声明变量，可以使用除go，try之外的控制流语句 C++17 lambda可以是constexpr的 if constexpr C++20 consteval函数只能在编译期执行（比constexpr严格） constinit声明拥有静态或线程存储期的变量。 虚函数constexpr constexpr函数内部允许new/delete","categories":[{"name":"现代C++","slug":"现代C","permalink":"http://example.com/categories/%E7%8E%B0%E4%BB%A3C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"引用","slug":"现代C++-2-引用.md","date":"2022-04-13T15:59:06.000Z","updated":"2022-09-22T15:45:02.218Z","comments":true,"path":"2022/04/13/现代C++-2-引用.md/","link":"","permalink":"http://example.com/2022/04/13/%E7%8E%B0%E4%BB%A3C++-2-%E5%BC%95%E7%94%A8.md/","excerpt":"","text":"本篇文章采用循序渐进的手法，首先讨论函数体内的引用使用，然后讨论函数间引用传递，然后引入模板参数，最后引入cv限制符 函数体内部（无类型推导，无cv限制符）对于每一个量做以下划分： 左值：有地址的值 右值：没有地址的值 左值引用 右值引用 左值引用只可以接受左值、左值引用、右值引用。 右值引用只可以接受右值。 函数之间（无类型推导，无cv限制符）对于函数的形参类型做以下划分： 无引用 左值引用 右值引用 无引用（接收左值，右值，左值引用，右值引用）：用传来的实参初始化一个左值。 左值引用（接收左值，左值引用，右值引用）：用传来的实参初始化一个左值引用。 右值引用（接收右值）：用传来的实参初始化一个右值引用。 对于函数的返回值类型做以下划分： 无引用 左值引用 右值引用 无引用：返回值是右值 左值引用：返回值是左值引用，用return值来初始化。 右值引用：返回值是右值，用return值来初始化。 类型推导用类型推导初始化变量时（函数体内部）： 无引用 左值引用 万能引用 无引用：去掉给定值的类型的引用，剩下来的部分即为T（此外如果T自己有cv修饰，那么T不包含cv），随后按照无类型推导规则确定值类型。 左值引用：去掉给定值的类型的引用，剩下来的部分即为T（此外如果T自己有cv修饰，那么T不包含cv），随后按照无类型推导规则确定值类型。 万能引用： 给定值为右值，T为给定值类型（T&amp;&amp;为变量类型） 给定值为左值，T为给定值类型（T&amp;为变量类型） 给定值为左值引用，T为相同类型的左值引用（T为变量类型） 给定值为右值引用，T为相同类型的左值引用（T为变量类型） （此外如果T自己有cv修饰，那么T不包含cv） 用类型推导形参推导函数匹配时：（除了这种情况：“右值匹配无引用与左值引用”之外。无引用必和有引用冲突） 右值—&gt;万能引用 左值—&gt;左值引用/万能引用（此时左值引用与万能引用等效） 左值引用—&gt;左值引用优先—&gt;万能引用 右值引用—&gt;左值引用优先—&gt;万能引用 用类型推导函数返回值时（即使用auto）： 无引用，返回值是右值 左值引用，返回值是左值引用 万能引用：按推导返回值，再按照无类型推导的返回值返回","categories":[{"name":"现代C++","slug":"现代C","permalink":"http://example.com/categories/%E7%8E%B0%E4%BB%A3C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"RAII","slug":"现代C++-4-RAII","date":"2022-04-13T15:59:06.000Z","updated":"2022-09-22T15:36:13.383Z","comments":true,"path":"2022/04/13/现代C++-4-RAII/","link":"","permalink":"http://example.com/2022/04/13/%E7%8E%B0%E4%BB%A3C++-4-RAII/","excerpt":"","text":"RAII，即“资源分配即初始化”的英语缩写。 在C++里，有些操作是需要成对出现的，比如new和delete。 此外还有一个操作是成对出现的：对象的构造与析构。 把new放进构造里面，delete放进析构里面，这样new和delete就和对象绑在一起了，在对象被析构时delete就会自动被调用了。这就是RAII的典型案例。 C++标准库中就有这样的设备，叫做“智能指针”。 #include 尝试使用智能指针，免去手动delete的麻烦。 智能指针unique_ptrunique_ptr 可以在大多数需要使用指针的场合下使用。以下是它的特点： unique_ptr 析构时会 delete 它所指的对象。 unique_ptr 指向的对象被其“独占”。 注意第二条，这是 unique_ptr 的主要特点，使用时不要有意违抗，否则可能出现多次delete情况。 使用方法 12345678910std::unique_ptr&lt;所指对象类型&gt; p1(new 所指对象类型);//初始化成功//来看点有意思的std::unique_ptr&lt;所指对象类型&gt; p2 = p1;//喜提报错一条，原因：p1独占资源std::unique_ptr&lt;所指对象类型&gt; p3;p3 = p1;//喜提报错一条，原因：p1独占资源 看到了吧，只要unique_ptr不放手，其他unique_ptr就没法获取它占有的资源。 1234567891011121314p1 = nullptr;//释放p1资源并将其置空std::unique_ptr p4(p1.release());//移交p1.reset();//释放p1资源p2.reset(p1.release());//释放p2并移交p1给p2传递删除器std::unique_ptr&lt;T, D&gt; p1(new T, D d);//d是可调用对象，析构时调用d来删除资源。","categories":[{"name":"现代C++","slug":"现代C","permalink":"http://example.com/categories/%E7%8E%B0%E4%BB%A3C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"lambda发展史","slug":"现代C++-3-lambda发展史.md","date":"2022-04-13T15:59:06.000Z","updated":"2022-09-22T15:45:16.999Z","comments":true,"path":"2022/04/13/现代C++-3-lambda发展史.md/","link":"","permalink":"http://example.com/2022/04/13/%E7%8E%B0%E4%BB%A3C++-3-lambda%E5%8F%91%E5%B1%95%E5%8F%B2.md/","excerpt":"","text":"C++11 引入labmda表达式 C++14 参数可以auto 表达式捕获 C++17 更加智能的自动返回值推导 可以使用*this捕获所在类的副本 可以constexpr C++20 constexpr lambda this指针不再可以用=隐式捕获 可以使用模板","categories":[{"name":"现代C++","slug":"现代C","permalink":"http://example.com/categories/%E7%8E%B0%E4%BB%A3C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"时间库","slug":"现代C++-5-时间库","date":"2022-04-13T15:59:06.000Z","updated":"2022-09-22T15:36:16.712Z","comments":true,"path":"2022/04/13/现代C++-5-时间库/","link":"","permalink":"http://example.com/2022/04/13/%E7%8E%B0%E4%BB%A3C++-5-%E6%97%B6%E9%97%B4%E5%BA%93/","excerpt":"","text":"C++11中引入了时间库。 需要#include 时间类时间库中主要有两个大类：时间点类和时间段类 下面是时间段类演示 12345678std::chrono::seconds time1(60);//定义了一个名字叫time1的 “时间段” 类型的变量，值为60秒std::chrono::hours time2(1);//定义了一个名字叫time2的 “时间段” 类型的变量，值为1小时//同理还有分钟minutes，毫秒milliseconds，微秒macroseconds，纳秒nanoseconds//这很好想明白吧 下面是时间点类演示 1234567std::chrono::steady_clock::time_point t1;//没错，这个类的名字叫std::chrono::steady_clock::time_pointt1 = std::chrono::steady_clock::now();//没错，这个函数叫std::chrono::steady_clock::now()，它可以获取当前时间 时间运算与输出小学的时候我们就学过：（别死记硬背，自己推导） 时间点 + 时间点 没有意义 时间点 - 时间点 = 时间段 时间点 ± 时间段 = 时间点 时间段 ± 时间段 = 时间段 这个库通过运算符重载实现了这样的加减转化，就是说，你可以将两个时间点相减，得到的直接是一个时间段，神奇吧。 比方说我们要测一大段代码的执行时间 1234567891011auto t1 = std::chrono::steady_clock::time_point::now();//auto真是我们的好伙伴//一大段代码//一大段代码//一大段代码auto t2 = std::chrono::steady_clock::time_point::now();auto duration = t2 - t1;//这里默认推导是纳秒，不想要纳秒可以不用类型推导 好，这样就得到一个时间段了，接下来要把它输出。 12std::cout&lt;&lt;duration.count();//这里duration.count()返回的是一个long long类型的值 想转化一下duration的单位？ 1234duration = std::chrono::duration_cast&lt;要转化成的类型&gt;(duration);//这里 “要转化的类型” 就是前面提到的时间段类//比如 std::chrono::seconds 这些便是所有常用操作了。 对了这个库没法输出时间点类型，真遗憾~","categories":[{"name":"现代C++","slug":"现代C","permalink":"http://example.com/categories/%E7%8E%B0%E4%BB%A3C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"模型索引","slug":"Qt文档译注-2-模型索引","date":"2022-04-12T15:59:06.000Z","updated":"2022-09-22T15:36:26.144Z","comments":true,"path":"2022/04/12/Qt文档译注-2-模型索引/","link":"","permalink":"http://example.com/2022/04/12/Qt%E6%96%87%E6%A1%A3%E8%AF%91%E6%B3%A8-2-%E6%A8%A1%E5%9E%8B%E7%B4%A2%E5%BC%95/","excerpt":"123456789QModelIndex与QAbstractItemModel一同定义，用以索引模型（model）中的项（Item）。由于所有模型都是以“行“、”列”、“层级”结构组织的，我们可以使用统一的方式索引模型中的项。所有模型都使用QModelIndex作为模型的索引。QModelIndex内部包含了行信息、列信息与指向所属模型的指针，因此理论上可以做很多事。文档原文：https://doc.qt.io/qt-5/qmodelindex.html 详细信息","text":"123456789QModelIndex与QAbstractItemModel一同定义，用以索引模型（model）中的项（Item）。由于所有模型都是以“行“、”列”、“层级”结构组织的，我们可以使用统一的方式索引模型中的项。所有模型都使用QModelIndex作为模型的索引。QModelIndex内部包含了行信息、列信息与指向所属模型的指针，因此理论上可以做很多事。文档原文：https://doc.qt.io/qt-5/qmodelindex.html 详细信息 这个类可以用作QAbstractModel以及从它所派生的模型的索引。“视图”（view）、“代理”（delegate）和“选择模型”（selection models）都使用索引来定位模型中的项。 QModelIndex 的默认构造函数只能创建无效索引，有效的QModelIndex对象应由模型使用QAbstractItemModel::createIndex 函数创建。模型中的最高级项的父索引是无效索引。 QModelIndex 不止一个构造函数，但是除了无参数的构造函数外，其他的构造函数（能创造出有效索引的构造函数）都被设置为私有 QAbstractItemModel 是 QModelIndex 的友元，它可以访问这些私有构造函数来创建出有效的索引。 所有模型都是 QAbstractItemModel 的子类（或间接子类），它们继承了QAbstractItemModel的createIndex函数。 QModelIndex可以用来引用模型中的项，它包含确定这个项在模型中的位置所需的所有信息。索引拥有行信息、列信息，并且可能拥有父索引，可以使用row()、column()和parent()函数来获取这些信息。模型中的每个顶级项都由一个没有父索引的模型索引表示，在这种情况下，parent()将返回一个无效的模型索引，这种情况相当于使用QModelIndex()来构造无效索引。 （Qt5.15） QModelIndex 拥有这些私有变量： ​ int r, c; ​ quintptr i; ​ const QAbstractItemModel *m; 其中 r 与 c 是行列信息，m 是其所属的模型的指针。i 是用来把索引和底层数据结构联系起来的 void 指针。 QModelIndex 没有指向其父索引的指针，QModelIndex 的 parent 函数是通过调用其对应模型的 parent 函数实现的。 要获取模型中某个项的索引，请调用QAbstractIemModel::index()，这个函数需要三个参数：行数、列数、父索引的引用。引用模型中的顶级项时，应提供无效索引作为父索引。 QAbstractIemModel::index()是一个纯虚函数，各个模型有不同的实现。 接口： QModelIndex QAbstractItemModel::index(int row, int column, const QModelIndex &amp;parent = QModelIndex()) const 第三个参数已经默认是无效索引，因此创建顶级项索引时传一个无效索引进去其实是多此一举。 model() 函数的作用是：返回索引对应模型的指针（const QAbstractItemModel*）。 child() 函数的作用是：获取该索引的子项目。 sibling() 函数的作用是：遍历模型中与本索引同级别的项。 注意：应立即使用模型索引，然后丢弃。在调用更改模型结构或删除项的模型函数后，不应认为索引仍然有效。如果需要长时间保留模型索引，请使用QPersistentModelIndex。 另请参见模型/视图编程、QPersistentModelIndex和QAbstractItemModel。 成员函数QModelIndex::QModelIndex()创建无效模型索引，用以指示模型中的某位置无效。 另请参见isValid()和QAbstractItemModel。 int QModelIndex::column()const返回索引所引用的元素所在的列数。 QVariant QModelIndex::data(int role=Qt::DisplayRole)const给定角色(role)，返回索引引用的项的数据。 Qt::ItemFlags QModelIndex::flags() const返回索引引用的项的标志(flag)。 此函数在Qt 4.2中引入。 quintptr QModelIndex::internalId() const返回将索引与内部数据结构关联的quintptr，这个quintptr被模型所使用。 另请参见QAbstractItemModel::createIndex()。 void* QModelIndex::internalPointer() const返回将索引与内部数据结构关联的void*指针，这个指针被模型所使用。 另请参见QAbstractItemModel::createIndex()。 bool QModelIndex::isValid()const如果此模型索引有效，则返回true；否则返回false。 有效索引属于模型，并且具有非负的行号和列号。 另请参见model()、row()和column()。 如果模型索引内部那个指向模型的指针非空，而且行列数非负，那么这个索引有效。 const QAbstractItemModel* QModelIndex::model()const返回指向此索引对应模型的指针。 返回值是常量指针，因为调用模型的非常量函数可能会使模型索引无效，并可能使应用程序崩溃。 QModelIndex QModelIndex::parent()const返回模型索引的父索引，如果没有父索引，则返回QModelIndex()。 另请参见 sibling() 和 model()。 int QModelIndex::row()const返回索引所引用的元素所在的列数。 QModelIndex QModelIndex::sibling(int row，int column)const返回该索引的兄弟。如果此位置没有兄弟，则返回无效的QModelIndex。 另请参见 parent(), siblingAtColumn(), 和 siblingAtRow()。 QModelIndex QModelIndex::siblingAtColumn(int column)const返回该索引的当前列的兄弟。如果此位置没有兄弟，则返回无效QModelIndex。 此函数在Qt 5.11中引入。 另请参见sibling() and siblingAtRow()。 QModelIndex QModelIndex::siblingAtRow(int row) const返回该索引的当前行的兄弟。如果此位置没有兄弟，则返回无效QModelIndex。 此函数在Qt 5.11中引入。 另请参见sibling() and siblingAtColumn()。 bool QModelIndex::operator=(const QModelIndex &amp;other)const如果此模型索引与其他模型索引引用的位置不同，则返回true；否则返回false。 bool QModelIndex::operator&lt;(const QModelIndex &amp;other)const如果此模型索引小于其他模型索引，则返回true；否则返回false。 小于计算对开发人员没有直接的帮助，没有定义具有不同父级的索引进行比较的方式。此运算符的存在只是为了使该类可以与QMap一起使用。 Qt 4.1中引入了此函数。 bool QModelIndex::operator==(const QModelIndex&amp; other)const如果此模型索引引用的位置与其他模型索引相同，则返回true；否则返回false。 与其他模型索引进行比较时，将使用内部数据指针、行、列和模型值。","categories":[{"name":"Qt技术文档","slug":"Qt技术文档","permalink":"http://example.com/categories/Qt%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"网络层数据平面","slug":"计算机网络笔记-3-网络层数据平面","date":"2022-04-12T15:59:06.000Z","updated":"2022-09-25T02:55:16.537Z","comments":true,"path":"2022/04/12/计算机网络笔记-3-网络层数据平面/","link":"","permalink":"http://example.com/2022/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-3-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/","excerpt":"","text":"Network Layer : Data Planenetwork layer : host to host communication service the per-router functions in the layer that determine how a datagram arriving on a router’s input links is forwarded to one of that router’s output linkstraditional IP forwarding and generalized forwardingIPV4 and IPV6 The primary role of the network layer is deceptively simple，to move packets froma sending host to a receiving host Forwarding. When a packet arrives at a router’s input link, the router must move the packet to the appropriate output link Forwarding and routingForwarding refers to the router-local action of transferring a packet from an inputlink interface to the appropriate output link interface. Forwarding takes place at veryshort timescales (typically a few nanoseconds), and thus is typically implemented inhardware. Routing refers to the network-wide process that determines the end-to-endpaths that packets take from source to destination. Routing takes place on much longertimescales (typically seconds), and as we will see is often implemented in software. We can think of forwarding as the process of gettingthrough a single interchange: A car enters the interchange from one road and deter-mines which road it should take to leave the interchange. We can think of routing asthe process of planning the trip from Pennsylvania to Florida: Before embarking onthe trip, the driver has consulted a map and chosen one of many paths possible, witheach path consisting of a series of road segments connected at interchanges. WFQ different from round robin in???(P341)","categories":[{"name":"计算机网络笔记","slug":"计算机网络笔记","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://example.com/tags/Network/"}]},{"title":"网络层控制平面","slug":"计算机网络笔记-4-网络层控制平面","date":"2022-04-12T15:59:06.000Z","updated":"2022-09-25T02:55:36.531Z","comments":true,"path":"2022/04/12/计算机网络笔记-4-网络层控制平面/","link":"","permalink":"http://example.com/2022/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-4-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/","excerpt":"","text":"Network Layer : Control Planeflow table和forwarding table是如何计算出来的？有两个方法可以用来做这个事，Per-router control，独立的路由算法在路由器之间交互；Logically centralized control，逻辑中心控制器计算并分发。 集中式路由算法使用完全的，全局的网络信息来计算最短路径。这种算法一般叫LS算法。分散式路由算法，没有节点具有有关所有网络链接的成本的完整信息。相反，每个节点开始只需了解自身直接连接的成本。节点逐渐计算到目标的最小成本路径称为距离向量（DV）算法。 静态路由算法，路线改变很慢。动态路由算法，经常改变路线。 按照算法是否对路线负载敏感也可以分类。 LS算法使用link-state-broadcast，每个节点都广播与自己相邻节点信息，这样所有节点都知道信息。 迪杰斯特拉算法。 如果算法考虑了负载，可能会出现震荡现象，即很多路由器都会选取某一条空旷路径，致使它堵塞，然后又会选取另一条空旷路径。 解决办法：可以使算法不同时计算。 DV算法没看 两种算法的比较：。。。互有胜负，都被使用着。 OSPF背景：刚才讨论过的算法过于简单化了，在范围很大或者组织需要拥有自治权时，这样的模拟显然不能有效。但如果把路由器们组织autonomoussystems (ASs)，问题就得到了解 决。 ISP中的路由器与链接构成AS，有的ISP有多个AS。每个AS都有独特编号，像IP地址，被ICANN注册管理。 同一个路由器中的AS运行同一套算法。在AS内部的算法叫做自治系统内路由协议intra-autonomous system routing protocol。 OSPF：Open Shortest Path First开放最短路径优先。是LS算法，每个路由器建立完全的拓扑图，单独运行迪杰斯特拉，单个链接成本由网络管理员配置。 有时候网络操作员会配置特定权重以实现特定流量控制。 OSPF时常更新链路权值以增强稳定性。 优点：安全，交换可以被鉴定，只有被信任的路由器可以参与，有两种认证方式，simple和MD5；多个同长路径可同时使用；单播和多播路由支持；在单个AS内部支持层级结构，OSPF自治系统被分为多个区域，边界路由器需要担起路由外部包裹的职责，OSPF也需要划分出主心骨区域，包裹从边界路由器开始路由，然后通过主干路由到目标区域中的区域边界路由器，然后路由到最终目的地。 BGPAS之间的路由协议。所有AS都运行BGP，Border Gateway Protocol，边界网关协议。 去中心化，异步，使用DV算法。 包裹不再被路由到某个特定地址，而是去往CIDRized prefixes，每个前缀代表一个子网或子网的集合。 BGP为路由器提供了以下的方法： 获取某个前缀是否可达的信息，从相邻AS中。 A subnet screams, “I exist and I am here,” and BGP makes sure that all the routers in the Internet know about this subnet。 确定前缀的“最佳”路径the router will locally run a BGP route-selection procedure (using the prefix reachability information it obtained via neighboring routers). The best route will be determined based on policy as well as the reachability information。 对于每个AS，路由器要么是内部路由器要么是网关路由器，网关路由器和其他AS的路由器直接相连。 广播BGP协议时，每个AS不仅知道了某个前缀存在，还知道了前缀所属AS的路径（它是走什么路发过来的）。 BGP信息由路由器交换，每一对路由器建立半永久TCP连接使用端口179，这样的TCP连接和发送的BGP信息，叫做BGP连接。 跨AS的BGP连接叫external BGP（eBGP）connection，内部的叫做internal BGP（iBGP）connection。 每个路由器都知道了前缀的存在。 BGP信息有多条属性，其中包括AS-PATH和NEXT-HOP，AS-PATH属性包含了从前缀的源头开始经过的一系列AS，路由器更新AS-PATH时会防止循环。 NEXT-HOP（下一跳节点）属性提供了AS间和AS内路由协议之间的关键链接，具有微妙但重要的用途。NEXT-HOP属性是开始AS-PATH的路由器接口的IP地址。比如“AS2 AS3 x”被AS1收到，NEXT-HOP就是AS1和AS2之间的路由器IP地址，且属于AS2。 （route：前缀与路径加附带的属性）热土豆路由。路由器决策时选择的路由（从所有可能的路由中）是到开始该路由的下一跳路由器的成本最低的路由。路由器尽可能快地将数据抛出所在AS。这是一种贪心算法。 事实上BGP使用比热土豆路由更复杂的算法 BGP在可能使用的路径中一个一个排除，直到只留下一个可用路径（使用以下的淘汰规则）。 路由被赋予了local preference属性，具有最高属性的路由将被选中。这个属性完全是由AS网络管理员决定的。 同时具有最高local preference属性的路由，具有最短的AS-PATH属性将被选中。 同时满足以上条件的，最短NEXT-HOP将被使用（即热土豆路由） 如果还有余下的，使用BGP identifier 这样的算法不再贪心。 BGP路由表包含超过50万条路由（即前缀和相应属性）。 IP-AnycastBGP还通常被用作实现IP-Anycast服务的手段，常被DNS使用。 打个比方，某些用户是如何使用IP-Anycast服务的呢？一个CDN为他的多个服务器注册了同一个IP地址，使用标准BGP广播，这样路由器可以利用BGP机制找出最近的服务器。 然而CDN实际上不常使用IP-anycast，因为同一个TCP连接的包可能到达不同服务器。DNS却广泛使用IP-anycast。 通过控制AS routing policy（最高权力），可以完成一些特殊控制。 商业ISP遵循的一条经验法则是，任何流经ISP主干网的流量必须在作为该ISP客户的网络中有一个源或一个目的地（或两者兼有）；否则，流量将在ISP网络上免费获得。 大串烧：假设您刚刚创建了一家拥有多台服务器的小公司… 首先需要获取网络连接，要和本地ISP联系，把自己的网关路由连到ISP路由器上面。然后ISP交出一段IP地址范围。这时候就可以给服务器们赋上地址啦，一个给Web服务器，一个给邮件服务器，一个给公司DNS服务器，一个给网关路由器… 然后需要和Internet registrar联系，获取一个域名。把自己DNS服务器地IP地址给他们，他们会把域名和相应的IP地址条目插进.com顶级域名服务器，这时候外界的人就可以用域名访问到公司DNS服务器了。 还有一步没完成呢，别的路由器还不知道怎么路由这些数据报呢。本地ISP需要使用BGP来把分配的前缀广播出去，这下所有路由器都知道公司的前缀了（或者是知道某个包含公司前缀的合计（aggregate）了）。 SDN 前情回顾：4.4Generalized Forwarding and SDN destination-based forwarding的两步match：寻找目标IP地址action：把包送到特定输出端口 Generalized forwarding: 每个分组交换机包含一个 match-plus-action table（由远程控制者计算并分发） 接下来的关于广义转发的讨论将基于Open Flow。 在OpenFlow里match-plus-action forwarding table 被叫做flow table，每一个条目都包含： 一组header field value 用于匹配包 一组计数者，在有包被匹配时更新 一组要采取的行动（Action），这样的行动多种多样。 对Match成功的包执行Action Match：OpenFlow的匹配可以基于连接层，网络层，传输层。OpenFlow使得一个设备既能具有层级3的能力，也有层级二的。 包的头部有十二个值，包括源与目的地MAC、IP、Port，VLAN信息，协议信息，Eth Type，ingress port（包被收纳的入口端口）等等。 有些部分被匹配，有些部分却不会。巴特勒·兰普森：一次做一件事，把它做好。接口应该捕获抽象的最基本要素。不要一概而论；概括通常是错误的。 Action：每个条目都有0个或以上的动作，用于施加给匹配成功的包。这些动作包括： 转发（forwarding），发送到目的端口、所有端口、部分端口、远程控制器… 丢掉（Dropping） 修改域（Modify-field） 这么做有很多好处，包括可以使用同一套硬件完成不同功能。 好的回到控制层。 有四个SDN关键特征： 基于流的转发。匹配可以基于传输层网络层与链路层，与传统匹配方式形成了鲜明对比。计算、组织、安装流表在交换机上是SDN控制层的责任。 数据层与控制层分离。数据层包含网络交换机们——简单而高速地执行“匹配然后动作”的设备；控制层包含服务器和软件。 在数据层交换机之外的网络控制功能。控制器拥有精确的网络状态信息，提供给在控制层上运行的网络控制应用，它还提供应用程序们监控、编程、控制底层网络设备的途径。此外控制器只是逻辑上中心化，实际上有很多控制器。 可编程的网络。网络可以通过运行在控制层的应用程序来被编程。应用程序们使用控制器提供的API控制数据层的设备们。 此外还看到SDN网络的解耦合特性。各个设备不一定要同一个厂家生产。 SDN控制层分为两个部分：SDN控制器和SDN网络控制应用程序。 SDN控制器的功能可以分三层： 对话层，SDN控制器和被控制的设备进行对话。这是最底层，两者之间的对话被称作是“southbound”接口。 网络范围的状态管理层。SDN控制层需要底层信息。所有信息均构成SDN控制器维护的网络范围“状态”的示例。 网络控制应用层的接口。控制器通过其“northbound”接口与网络控制应用程序交互P426这张图很形象。 下面看看OpenFlow协议，它可以用来在SDN控制器和被控制设备之间通信（在对话层） OpenFlow PortocolOpenFlow在tcp上工作，端口是6653 以下这些信息常被控制器发送： 配置。使控制器查询和设置一台交换机的配置参数 更改状态。增删流表的条目，设置交换机端口属性。 读状态。控制器收集统计信息和计数器值。 发包。控制器自己发一个特定的包到交换机特定端口，这条信息包含了整个包。 SDN交换机发送这些信息： 流被移除。通知控制器一条流表条目被移除了 端口状态。通知控制器端口状态的改变。 送包进来（packet-in）。送一个包给控制器，当匹配失败或者匹配成功的某种情况。 谷歌的B4网络与SDN息息相关。 一个例子（Dijkstra的算法作为单独的应用程序在交换机之外执行。分组交换机向SDN控制器发送链路更新，而不是相互发送） SDN给了ISP很高的自由度，且ISP能更方便地操作路由器。 ICMP：the internet control message protocol用作主机和路由器之间互相沟通网络层信息。ICMP看上去是IP的一部分，但是结构上它是在IP之上的。ICMP是作为IP数据报的负载被传送的，就像TCP和UDP段一样。ICMP都具有type和code域ICMP常用于报告错误或者异常情况。ping和Traceroute是基于ICMP特性的。 SNMP，NETCONF/YANG除了SDN，还有一些工具能够管理网络。 “网络管理包括硬件、软件和人员要素的部署、集成和协调，以监控、测试、轮询、配置、分析、评估和控制网络和要素资源，以合理的成本满足实时、操作性能和服务质量要求。” 网络管理的关键组件： 管理服务器。是一个应用程序。控制。 被管理的设备。在管理网络里的设备（包括软件） 数据。有配置数据，操作数据，设备统计数据 网络管理agent。运行在被管理的设备里，与管理服务器沟通 网络管理协议。需要注意的是，网络管理协议本身并不管理网络。相反，它提供了网络管理员可以用来管理（“监视、测试、轮询、配置、分析、评估和控制”）网络的功能。这是一个微妙但重要的区别。 有三种常用的方式管理网络： CLI。直接command line interface来命令设备。命令直接在被管理设备的控制台上敲击，或通过Telnet或者secure shell（SSH）连接。很难，易出错，难以管理大型网络。家庭无线路由器可以用HTTP连上然后配置，这样做比CLI不容易出错一点。 SNMP/MIB。Simple Network Management Protocol（SNMP）与Management Information Base（MIB）。网络操作员可以使用SNMP查询、设置在MIB里的数据。然后CLI。以上两种管理方式都是管理单独设备的。SNMP/MIB在管理大型网络时有短板。 NETCONF/YANG。更抽象，更广大，更全观。YANG是一种数据建模语言，用于建模配置和操作数据。NETCONF协议用于将YANG兼容的操作和数据与远程设备进行通信。 SNMP和MIBThe Simple Network Management Protocol version 3是应用层协议，用来传输网络管理控制和信息，在管理服务器和代表那台服务器做事的agent之间。 SNMP信息可以双向发送，用于通知、查询，更改MIB信息等。 MIB对象被SMI(Structure of Management Information 用于保证数据语法词法被很好地定义同时)语言详细描述。 PDU：protocol data units，是SNMPv3定义的7种消息类型。 GetRequest GetNextRequest GetBulkRequest(这三个是粒度上的差别) InformRequest SetRequest Response SNMPv2-Trap PDU一般是装在UDP里的 被管理设备的操作状态数据等数据在SNMP/MIB方法里是被呈现为被集合在一起而成为MIB的对象们的。相关MIB对象被聚集成为MIB模块。 The Network Configuration Protocol (NETCONF) and YANG NETCONF在管理服务器和受管设备之间运行，用于（i）检索、设置和修改受管设备配置（ii）查询受管设备运行数据和统计数据（iii）订阅受管设备生成的通知。管理服务器通过发送结构化XML文档中指定的配置并激活受管设备上的配置，主动控制受管设备。NETCONF使用远程过程调用（RPC）范式，其中协议消息也以XML编码，并通过安全的、面向连接的会话（如TLS（传输层安全）协议）在管理服务器和受管设备之间进行交换。 NETCONF Operation如下： , YANGdata modeling language来精确描述网络数据的结构词法语法，被NETCONF所使用。","categories":[{"name":"计算机网络笔记","slug":"计算机网络笔记","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://example.com/tags/Network/"}]},{"title":"传输层","slug":"计算机网络笔记-2-传输层","date":"2022-04-12T15:59:06.000Z","updated":"2022-09-25T02:55:02.247Z","comments":true,"path":"2022/04/12/计算机网络笔记-2-传输层/","link":"","permalink":"http://example.com/2022/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-2-%E4%BC%A0%E8%BE%93%E5%B1%82/","excerpt":"","text":"Transport LayerThe central piece of the layered network architecture transport layer provide logical communication between processes as if the two processes are in the same host transport layer do its work in the host, the out-of-host teleport is done by the network service some of the transport layer’s service is constrained by the network layer network layer protocal has a name – IP(Internet Protocal, which provides logical communication between hosts IP makes its “best effort to deliver segments between hostsbut not guarantees each host has its IP address UDP and TCP extends IP’s delivery service between two end systems to that between two processes, which is called multiplexing Multiplexing and DemultiplexingMultiplexing:gathering data chunks at the source host from different sockets, encapsulate each chunk with header to create segment, and pass to the network later Demultiplexing:delever the data in a segment to correct socket requires : unique identifiers of socket(port) each segment have special field indicating the socket to be delivered port number: 0~65565 UDP MultiplexingUDP socket:two-tupledestination IP address destination port numberthe host uses them to direct (demultiplex) the segment to the appropriate socket. TCP MultiplexingTCP socket:four-tuplesource IP addresssource port numberdestination IP address destination port numberthe host uses all four values to direct (demultiplex) the segment to the appropriate socket. UDPmultiplexing/demultiplexing and some light error checking takes messages from application, attaches source and destination port number field and 2 other small field and pass it to the network layer The network layer encapsulates the transport-layer seg-ment into an IP datagram and then makes a best-effort attempt to deliver the segment to the receiving host. connectionless, no handshake DNS:using UDPUsing UDP Finer application-level control over what data is sent, and when. No connection establishment. No connection state. Small packet header overhead. UDP Segment StructureThe UDP header has four fieldseach consisting of 2 bytes: Source port Dest Port Length Checksum Then the Application Data The UDP Checksum provides error detectionthe checksum is used to determine whether bits within the UDP segment have been altered (for example, by noise in the links or while stored in a router) as it moved from source to destination. Principles of Reliable Data Transfer“view lower layer simply as an unreliable point-to-point channel” V1.0over a perfectly reliable channel Just packet the data and deliver it V2.0over a channel with Bit Errors three additional protocol capabilities are required in ARQ protocols to handle the presence of bit errors: Error Detection.Extra bits needed Receiver Feedback. Retransmission. deliver and wait for a NAK or ACKthus decide whether to retransmitStop and Wait Fatal flaw : ACK or NAK packet could be corruptedPossible solution repeat asking sentence enough checksum to allow recovering sender resend when corrupted ACK/NAK received Real solutionadd a new field to the data packet, Sequence number, 1 bit V2.1 V2.2NAK not need and solve the problem? V3.0Solve the problem of packet loss as well But Stop and Wait performed not fast enough Pipelining the range of the sequence number must be increased buffer more than one packet Basic approaches toward pipelined error recovery Go-Back-Ntransmit multiple packets (when available) without waiting for an acknowledgment, but is constrained to have no more than some maximum allowable number, N, of unacknowledged packets in the pipeline sliding-window protocolTCP sequence numbers count bytes in the byte stream rather than packets.Illustration P231 Selective RepeatAvoid unnecessary retrans-missions by having the sender retransmit only those packets that it suspects were received in error (that is, were lost or corrupted) at the receiver) the window size must be less than or equal to half the size of the sequence number space for SR protocols P237 All the techniques to guarantee reliable data transfer Connected-Oriented Transport : TCPTCP—the Internet’s transport-layer, connection-oriented, reliable transport protocol. The TCP Connectionhandshake:send some preliminary segment to each other to establishment. “The connection” is a logical one, not an end-to-end TDM or FDM circuit in a circuit-switch networkcommon stateresids only in the TCPs in the two communicating end systems.TCP protocol runs only in the end systems and not in the intermediate network elements (routers and link-layer switches), the intermediate routers are completely oblivious to TCP connections; they see datagrams, not connections. TCP : point-to-point three-way-handshake to establish the connection TCP pairs each chunk of client data with a TCP header, thereby forming TCP segments. The segments are passed down to the network layer, where they are separately encapsulated within network-layer IP datagrams. TCP Segment Structure The TCP segment consists of header fields and a data field. The data field contains a chunk of application data. the MSS limits the maximum size of a segment’s data field Structure Source and destination port numbers checksum field 32-bit sequence number field 32-bit acknowledgment number field 16-bit receive window 4-bit header length field options field 6-bit flag field 16-bit urgent data pointer field Illustration P242 Sequence Numbers and Acknowledgment NumbersTCP views data as an unstructured, but ordered, stream of bytes. TCP’s use of sequence numbers reflects this view in that sequence numbers are over the stream of transmitted bytes and not over the series of transmitted segments. The sequence number for a segment is therefore the byte-stream number of the first byte in the segment. Setting and Managing the Retransmission Timeout IntervalTimeoutInterval = EstimatedRTT + 4 DevRTT Reliable Data Transferuse only a single retransmission timer, even if there are multiple transmitted but not yet acknowledged segment. TCP responds to the timeout event by retransmitting the segment that caused the timeout. TCP then restarts the timer. When ACK accepted, and the ACK number &gt; expected, update the expected. Doubleing the timeout intervaleach time TCP retransmits, it sets the next timeout interval to twice the previous valueHowever, whenever the timer is started after either of the two other events (that is, data received from application above, and ACK received), the TimeoutInterval is derived from the most recent values of EstimatedRTT and DevRTT. Fast retransmitA duplicate ACK is an ACK that reacknowledges a segment for which the sender has already received an earlier acknowledgment(Receiver Action P255) Retransmit the last in-order byte of data it has received, to inform the sender to retransmit. When the sender receive 3 duplicate ACKs for the same data, it takes this as an indication that the segment following the segment that has been ACKed three times has been lost.Then it performs a fast retransmit. Go-Back-N or Selective RepeatMany TCP implementations will buffer correctly received but out-of-order segmentsacknowledge out-of-order segments selectively(QUESTION : conflict between multiple ACK and selective repeat) Flow Controleliminate the possibility of the sender overflowing the receiver’s buffer. sender maintain a variable called the receive window, used to give the sender an idea of how much free buffer space is available at the receiver.Host B tells Host A how much spare room it has in the connection buffer by placing its current value of rwnd in the receive window field of every segment it sends to A. connection managementthree-way handshakefour-way handshake when a host receives a TCP segment whose port numbers or source IP address do not match with any of the ongoing sockets in the host, the host will send a special reset segment to the source. This TCP segment has the RST flag bit (see Section 3.5.2) set to 1.When a host receives a UDP packet whose destination port number doesn’t match with an ongoing UDP socket, the host sends a special ICMP datagram, as discussed in Chapter 5. SYN flood attack and its defenceSYN cookie(not understand) Principles of Congestion ControlThe Causes and the Costs of Congestionscenario 1Two Senders, a Router with Infinite Buffers Found one cost of a congested network—large queuing delays are experienced as the packet-arrival rate nears the link capacity. scenario 2Two Senders and a Router with Finite Buffers Found another cost of a congested network—the sender must perform retransmissions in order to compensate for dropped (lost) packets due to buffer overflow. another cost of a congested network—unneeded retransmissions by the sender in the face of large delays may cause a router to use its link bandwidth to forward unneeded copies of a packet. another cost of dropping a packet due to congestion—when a packet is dropped along a path, the transmission capacity that was used at each of the upstream links to forward that packet to the point at which it is dropped ends up having been wasted. Approaches to Congestion ControlEnd-to-end congestion controlNetwork-assisted congestion control TCP Congestion ControlClassic TCP Congestion ControlIf a TCP sender perceives that there is little congestion on the path between itself and the destination, then the TCP sender increases its send rate; if the sender perceives that there is congestion along the path, then the sender reduces its send rate The TCP congestion-control mechanism operating at the sender keeps track of an additional variable, the congestion window. Principles: A lost segment implies congestion, and hence, the TCP sender’s rate should be decreased when a segment is lost. An acknowledged segment indicates that the network is delivering the sender’s segments to the receiver, and hence, the sender’s rate can be increased when an ACK arrives for a previously unacknowledged segment. Bandwidth probing. increase its rate in response to arriving ACKs until a loss event occurs, at which point, the transmission rate is decreased. the celebrated TCP congestion-control algorithm slow start congestion avoidance fast recovery Slow StartWhen a TCP connection begins, the value of cwnd is typically initialized to a small value of 1. double the sending rate every RTT if there is a loss event (i.e.,congestion) indicated by a timeout, the TCP sender sets the value of cwnd to 1 and begins the slow start process anew.it also set the value of a second state variable, ssthresh (short-hand for “slow start threshold”) to cwnd/2—half of the value of the congestion window value when congestion was detectedwhen the value of cwnd equals ssthresh, slow start ends and TCP transitions into congestion avoidance mode.The final way in which slow start can end is if three duplicate ACKs are detected, in which case TCP performs a fast retransmit (see Section 3.5.4) and enters the fast recovery state. Congestion Avoidancerather than doubling the value of cwnd every RTT, TCP adopts a more conservative approach and increases the value of cwnd by just a single MSS every RTT Fast Recovery TCP linearly increases its conges-tion window size (and hence its transmission rate) until a triple duplicate-ACK event occurs. It then decreases its congestion window size by a factor of two but then again begins increasing it linearly, probing to see if there is additional available bandwidth. TCP CUBICNetwork-Assisted Explicit Congestion Notification and Delayed-based Congestion Controlallow the network to explicitly signal congestion to a TCP sender and receiver.At the network layer, two bits (with four possible values, overall) in the Type of Service field of the IP datagram header (which we’ll discuss in Section 4.3) are used for ECN. FairnessTCP congestion control converges to provide an equal share of a bottleneck link’s bandwidth among competing TCP connections. Evolution of Transport-Layer Functionalitya rich evolution in the use of TCP over the past decade. There are versions of TCPspecifically designed for use over wireless links, over high-bandwidth paths with large RTTs, for paths with packet re-ordering, and for short paths strictly within data centers. QUIC : Quick UDP Internet ConnectionsQUIC is a new application-layer protocol designed from the ground up to improve the performance of transport-layer services for secure HTTP. Connection-Oriented and Secure.Streams.Reliable, TCP-friendly congestion-controlled data transfer.","categories":[{"name":"计算机网络笔记","slug":"计算机网络笔记","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://example.com/tags/Network/"}]},{"title":"应用层","slug":"计算机网络笔记-1-应用层","date":"2022-04-12T15:59:06.000Z","updated":"2022-09-25T02:53:53.022Z","comments":true,"path":"2022/04/12/计算机网络笔记-1-应用层/","link":"","permalink":"http://example.com/2022/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-1-%E5%BA%94%E7%94%A8%E5%B1%82/","excerpt":"","text":"Application Layerprinciplewhen developing your new application, you need to write software thatwill run on multiple end systems. This software could be written, for example, inC, Java, or Python. Importantly, you do not need to write software that runs on network-core devices architecturesclient-serverthere is an always-on host, called the server,which services requests from many other hosts, called clients. server has a fixed, well-known address, called an IP address. a clientcan always contact the server by sending a packet to the server’s IP address. A data center can have hundreds of thousands of servers P2Pthe application exploits direct communication between pairs of intermittently connected hosts, called peers. Client and Server ProcessesIn the context of a communication session between a pair of processes, the process that initiates the communication (that is, initially contacts the other process at the beginning of the session) is labeled as the client. The process that waits to be contacted to begin the session is the server. The Interface Between the Process and the Computer NetworkSocketLet’s consider an analogy to help us understand processes and sockets. A process is analogous to a house and its socket is analogous to its door. When a process wants to send a message to another process on another host, it shoves the message out its door (socket). This sending process assumes that there is a transportation infrastructure on the other side of its door that will transport the message to the door of the destination process. Once the message arrives at the destination host, the message passes through the receiving process’s door (socket), and the receiving process then acts on the message. The only control that the application developer has on the transportlayer side is (1) the choice of transport protocol and (2) perhaps the ability to fix a few transport-layer parameters such as maximum buffer and maximum segment sizes IPTo identify the receiving process, two pieces of information need to be specified: (1) the address of the host and (2) an identifier that specifies the receiving process in the destination host.a 32-bit quantity that we can think of as uniquely identifying the host. port number， the receiving socketPopular applica-tions have been assigned specific port numbers. For example, a Web server is identified by port number 80. A mail server process (using the SMTP protocol) is identified by port number 25. A list of well-known port numbers for all Internet standard protocols can be found at www.iana.org. Choose a transport layer services for applications Reliable Data Transfer Throughput Timing Security Transport Services Provided by the InternetTCP Connection-oriented service Reliable data transfer service UDPUDP is a no-frills, lightweight transport protocol, providing minimal services. UDP is connectionless, so there is no handshaking before the two processes start to com- municate. UDP provides an unreliable data transfer service—that is, when a process sends a message into a UDP socket, UDP provides no guarantee that the message will ever reach the receiving process. Furthermore, messages that do arrive at the receiving process may arrive out of order. TLSTCP’s enhancements being implemented in the application layer Application-Layer ProtocolsAn application-layer protocol defines how an application’s processes, running on different end systems, pass messages to each other. In particular, an application-layer protocol defines: The types of messages exchanged, for example, request messages and responsemessages• The syntax of the various message types, such as the fields in the message andhow the fields are delineated• The semantics of the fields, that is, the meaning of the information in the fields• Rules for determining when and how a process sends messages and responds tomessages HTTP, heart of the WebA Web page (also called a document) consists of objects. HTTP need not worry about lost data or the details of how TCP recovers from loss or reordering of data within the network. That is the job of TCP and the protocols in the lower layers of the protocol stack. the server sends requested files to clients without storing any state information about the client a stateless protocol. A Web server is always on, with a fixed IP address, and it services requests from potentially millions of different browsers. HTTP with Non-Persistent Connectionseach TCP connection is closed after the server sends the object—the connection does not persist for other objects. HTTP/1.0 employes non-persistent TCP connections. Note that each non-persistent TCP connection transports exactly one request message and one response message Indeed, users can configure some browsers to control the degree of parallelism. Browsers may open multiple TCP con-nection This HTTP request/response eats up another RTT. Thus, roughly, the total response time is two RTTs plus the transmission time at the server of the HTML file. shortcoming a brand-new connection must be established and maintained for each requested object. each object suffers a delivery delay of two RTTs HTTP with Persistent ConnectionsThe default mode of HTTP uses persistent connections with pipelining. HTTP Message FormatHTTP Request Messageordinary ASCII textlines, each followed by a carriage return and a line feed The last line is fol-lowed by an additional carriage return and line feed The first line of an HTTP request message is called the request line; the subsequent lines are called the header lines. The request line has three fields: the method field, the URL field, and the HTTP version field. The method field can take on several different values, including GET, POST, HEAD, PUT, and DELETE. The GET method is used when the browser requests an object, with the requested object identified in the URL field. let’s now look at the general format of a requestmessage, as shown in Figure 2.8.P113HTML forms often usethe GET method and include the inputted data (in the form fields) in the requested URL. The HEAD method is similar to the GET method. When a server receives a request with the HEAD method, it responds with an HTTP message but it leaves out the requested object. Application developers often use the HEAD method for debug-ging. The PUT method is often used in conjunction with Web publishing tools. It allows a user to upload an object to a specific path (directory) on a specific Web server. The PUT method is also used by applications that need to upload objects to Web servers. The DELETE method allows a user, or an application, to delete an object on a Web server. HTTP Response Message… Cookies a cookie header line in the HTTP response message; a cookie header line in the HTTP request message; a cookie file kept on the user’s end system and managed by the user’s browser a back-end database at the Web site Web Cachingproxy server conditional GET(1) the request message uses the GET method and (2) the request message includes anIf-Modified-Since: header line. HTTP/2enabling request and response multiplexing over a single TCP connection, provide request prioritization and server push, and provide efficient compression of HTTP header fields HTTP/2 changes how the data is formatted and transported between the client and server. with only 1 TCPcare for HOL problems The HTTP/2 solution for HOL blocking is to break each message into small frames, and interleave the request and response messages on the same TCP connection. use framing sublayerResponse Message Prioritization and Server Pushing。the server can push additional objects to the client, without the client having torequest each one HTTP/3QUIC, discussed in Chapter 3, is a new “transport” protocol that is implemented inthe application layer over the bare-bones UDP protocol Electronic MailMail servers form the core of the e-mail infrastructure. Each recipient, has a mailbox located in one of the mail servers. SMTPSMTP transfers messages from senders’ mail servers to the recipients’ mail servers. does not normally use intermediate mail servers for sending mail First, the client SMTP (running on the sending mail server host) has TCP establish a connection to port 25 at the server SMTP (running on the receiv-ing mail server host). If the server is down, the client tries again later. Once this connection is established, the server and client perform some application-layer handshaking—just as humans often introduce themselves before trans-ferring information from one to another, SMTP clients and servers introduce themselves before transferring information. During this SMTP handshaking phase, the SMTP client indicates the e-mail address of the sender (the person who gener-ated the message) and the e-mail address of the recipient. Once the SMTP client and server have introduced themselves to each other, the client sends the message. SMTP can count on the reliable data transfer service of TCP to get the message to the server without errors. The client then repeats this process over the same TCP connection if it has other messages to send to the server; otherwise, it instructs TCP to close the connection. send all of the messages over the same TCP connection. FormatThe commands in that section were part of the SMTP handshaking protocol;Every header must have a From: header line and a To: header line; a header may include a Subject: header line as well as other optional header lines. typically the send-er’s user agent does not dialogue directly with the recipient’s mail server. Instead, as shown in Figure 2.16, Alice’s user agent uses SMTP or HTTP to deliver the e-mail message into her mail server, then Alice’s mail server uses SMTP (as an SMTP cli-ent) to relay the e-mail message to Bob’s mail server. HTTP and IMAP approaches allow Bob to manage folders, maintained in Bob’s mail server. Bob can move messages into the folders he creates, delete messages, mark messages as important, and so on. DNS—The Internet’s Directory ServiceOne identifier for a host is its hostname. Hostnames—such as www.facebook.com, www.google.com, gaia.cs.umass.edu—are mnemonic and are therefore appreciated by humans hosts are also identified by so-called IP addresses The DNS is (1) a distributed database implemented in a hierarchy of DNS servers, and (2) an application-layer protocol that allows hosts to query the distributed database the DNS protocol runs over UDP and uses port 53 The same user machine runs the client side of the DNS application. The browser extracts the hostname, www.someschool.edu, from the URL and passes the hostname to the client side of the DNS application. The DNS client sends a query containing the hostname to a DNS server. The DNS client eventually receives a reply, which includes the IP address for the hostname. Once the browser receives the IP address from DNS, it can initiate a TCP con-nection to the HTTP server process located at port 80 at that IP address. it(1) runs between communicating end systems using the client-server paradigm and(2) relies on an underlying end-to-end transport protocol to transfer DNS messages between communicating end systems A Distributed, Hierarchical DatabaseRoot name servers provide the IP addresses of the TLD servers.For each of the top-level domains—top-level domains such as com, org, net, edu, and gov, and all of the country top-level domains such as uk, fr, ca, and jp—there is TLD server (or server cluster).TLD servers provide the IP addresses for authoritative DNS servers Every organization with publicly accessible hosts (such as Web servers and mail servers) on the Internet must provide publicly accessible DNS records that map the names of those hosts to IP addresses. An organization’s authoritative DNS server houses these DNS records. Resource RecordA resource record is a four-tuple that contains the following fields:(Name, Value, Type, TTL) To obtain the canonical name for the mail server, a DNS client would query foran MX record; to obtain the canonical name for the other server, the DNS clientwould query for the CNAME record.If Type=A, then Name is a hostname and Value is the IP address for the host-name. Thus, a Type A record provides the standard hostname-to-IP address map-ping. As an example, (relay1.bar.foo.com, 145.37.93.126, A) isa Type A record.• If Type=NS, then Name is a domain (such as foo.com) and Value is the host-name of an authoritative DNS server that knows how to obtain the IP addressesfor hosts in the domain. This record is used to route DNS queries further along inthe query chain. As an example, (foo.com, dns.foo.com, NS) is a TypeNS record If a DNS server is authoritative for a particular hostname, then the DNS serverwill contain a Type A record for the hostname. (Even if the DNS server is not author-itative, it may contain a Type A record in its cache.) If a server is not authoritativefor a hostname, then the server will contain a Type NS record for the domain thatincludes the hostname; it will also contain a Type A record that provides the IP addressof the DNS server in the Value field of the NS record. Peer-to-Peer Distributionpairs of intermittently connected hosts, called peers, communicate directly with each other. most popular P2P file distribution protocol is BitTorrent the collection of all peers participating in the distribution of a particular file iscalled a torrent. Peers in a torrent download equal-size chunks of the file from oneanother, with a typical chunk size of 256 KBytes. When a peer first joins a torrent, ithas no chunks. Over time it accumulates more and more chunks. While it downloadschunks it also uploads chunks to other peers. Once a peer has acquired the entirefile, it may (selfishly) leave the torrent, or (altruistically) remain in the torrent andcontinue to upload chunks to other peers. Also, any peer may leave the torrent at anytime with only a subset of chunks, and later rejoin the torrent. Video Streaming and Content Distribution Networksthey are implemented using application-level protocols and servers that function in some ways like a cache. In HTTP streaming, the video is simply stored at an HTTP server as an ordinary file with a specific URL. When a user wants to see the video, the client establishes a TCP connection with the server and issues an HTTP GET request for that URL. The server then sends the video file, within an HTTP response message, as quickly as the underlying network protocols and traffic conditions will allow. On the client side, the bytes are collected in a client application buffer. In DASH, the video is encoded into several different versions, with each version having a different bit rate and, correspondingly, a different quality level. The client dynamically requests chunks of video segments of a few seconds in length. When the amount of available bandwidth is high, the client naturally selects chunks from a high-rate version; and when the available bandwidth is low, it naturally selects from a low-rate version. The client selects different chunks one at a time with HTTP GET request messages With DASH, each video version is stored in the HTTP server, each with a differ-ent URL. The HTTP server also has a manifest file, which provides a URL for each version along with its bit rate. The client first requests the manifest file and learns about the various versions. The client then selects one chunk at a time by specifying a URL and a byte range in an HTTP GET request message for each chunk. While down-loading chunks, the client also measures the received bandwidth and runs a rate deter-mination algorithm to select the chunk to request next. Content Distribution NetworksThe CDN may be a private CDN, that is, owned by the content provideritself; for example, Google’s CDN distributes YouTube videos and other types ofcontent. The CDN may alternatively be a third-party CDN that distributes contenton behalf of multiple content providers; Akamai, Limelight and Level-3 all operatethird-party CDNs. A very readable overview of modern CDNs is [Leighton 2009;Nygren 2010].CDNs typically adopt one of two different server placement philosophies[Huang 2008]:• Enter Deep. One philosophy, pioneered by Akamai, is to enter deep into theaccess networks of Internet Service Providers, by deploying server clusters inaccess ISPs all over the world. (Access networks are described in Section 1.3.)Akamai takes this approach with clusters in thousands of locations. The goal isto get close to end users, thereby improving user-perceived delay and throughputby decreasing the number of links and routers between the end user and the CDNserver from which it receives content. Because of this highly distributed design,the task of maintaining and managing the clusters becomes challenging.• Bring Home. A second design philosophy, taken by Limelight and manyother CDN companies, is to bring the ISPs home by building large clustersat a smaller number (for example, tens) of sites. Instead of getting inside theaccess ISPs, these CDNs typically place their clusters in Internet ExchangePoints (IXPs) (see Section 1.3). Compared with the enter-deep design phi-losophy, the bring-home design typically results in lower maintenance andmanagement overhead, possibly at the expense of higher delay and lowerthroughput to end users. Most CDNs take advantage of DNS to intercept and redirect requests At the core of any CDN deployment is a cluster selection strategy Socket Programming: Creating Network ApplicationsTwo types：open or proprietary Socket Programming with UDPWe said that each process isanalogous to a house and the process’s socket is analogous to a door. The applicationresides on one side of the door in the house; the transport-layer protocol resides onthe other side of the door in the outside world. The application developer has controlof everything on the application-layer side of the socket; however, it has little controlof the transport-layer side. When a socket is created, an identifier, called a port number, is assigned to it Socket Programming with TCPUnlike UDP, TCP is a connection-oriented protocol. This means that before the cli-ent and server can start to send data to each other, they first need to handshake andestablish a TCP connection. One end of the TCP connection is attached to the clientsocket and the other end is attached to a server socket. When creating the TCP con-nection, we associate with it the client socket address (IP address and port number)and the server socket address (IP address and port number With the TCP connec-tion established, when one side wants to send data to the other side, it just drops thedata into the TCP connection via its socket. This is different from UDP, for whichthe server must attach a destination address to the packet before dropping it into thesocket. During the three-way handshake, the client process knocks on the welcom-ing door of the server process. When the server “hears” the knocking, it creates anew door—more precisely, a new socket that is dedicated to that particular client.In our example below, the welcoming door is a TCP socket object that we callserverSocket; the newly created socket dedicated to the client making the con-nection is called connectionSocket. Students who are encountering TCP sock-ets for the first time sometimes confuse the welcoming socket (which is the initialpoint of contact for all clients wanting to communicate with the server), and eachnewly created server-side connection socket that is subsequently created for com-municating with each client.","categories":[{"name":"计算机网络笔记","slug":"计算机网络笔记","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://example.com/tags/Network/"}]},{"title":"移动与无线网络","slug":"计算机网络笔记-6-无线与移动网络","date":"2022-04-12T15:59:06.000Z","updated":"2022-09-25T02:56:04.738Z","comments":true,"path":"2022/04/12/计算机网络笔记-6-无线与移动网络/","link":"","permalink":"http://example.com/2022/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-6-%E6%97%A0%E7%BA%BF%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/","excerpt":"","text":"Wireless and Mobile Networks7.1 简介以下这些元素在无线网络中： 无线主机。智能手机、平板电脑。连接上互联网的设备 无线链路。属性有：传输速率与覆盖范围等等。 基站。职责是向关联的无线主机收发数据。协调多个无线主机的传输。蜂窝塔和802.11无线局域网的“接入点”都是基站的例子。 当我们说一个主机“关联”（associated）一个基站时，意思是：1.主机在基站的通信范围内；2.主机使用那个基站来转送数据，在它自己和更大的网络之间。 主机与基站相连的模式叫做“基础设施模式”。没有基站的模式叫做“自组网”。 移动设备移动时，发生接入点变化的过程叫做handoff 或者handover。 网络基础设施。这就是主机想要连接上的更大的网络。 此章节的关键归类： 网络中的包是否穿过一个无线跃点（wireless hop）或是多个无线跃点。 是否有基础设施例如基站。 单无线跃点,基于基础设施。大多数网络是这样的。 单无线跃点，无基础设施。比如蓝牙网络。 多无线跃点，基于基础设施。使用中继，一些传感器网络属于此类。 多无线跃点，无基础设施。移动自组网。 本章主要讨论单无线跃点网络，多数讨论基于基础设施的网络。 无线链路和网络的特征。 随距离递减的信号强度。 其他信号源的干扰。在同一频带内发射的无线电波源会相互干扰。 多径传播。传播路径不同导致到达时间不同，信号会发生模糊。 这些特征意味着比特位错误会更加频繁。需要强力检查更正手段。 signal-to-noise ratio(SNR)是一个相对的衡量标准。单位是分贝。 对于给定的调制方式，信噪比越高，二进制误码率越低。 对于给定的SNR，一种具有更高比特传输速率的调制技术（无论是否出错）将具有更高的BER。 物理层调制技术的动态选择可用于使调制技术适应信道条件。 CDMAcode division multiple access属于channel partitioning 协议大家庭。在无线世界非常重要。 在发射一个比特位时，将它拆成M位于预先准备好的CDMA码相乘再发出去，接收者使用相同的CDMA码来解码。多个发送者同时发送时也可以解码成功。 WiFi：802.11 无线局域网不同的802.11 b、g、n、ac、ax标准都有一些共同的特征，包括802.11帧格式。它们向后兼容，使用CSMA/CA协议。 主要的差别在物理层。体现在传输频带不同。 结构基本的结构是“基本服务集合”BSS，包含一个或多个无线站和中心基站，中心基站叫做接入点（AP）。接入点连接路由器或交换机。 家庭网络一般有一个AP和一个路由器（一般是集成为一个单元）。 部署接入点的无线局域网通常被称为基础设施无线局域网。 IEEE 802.11站点也可以将自己分组，形成一个自组织网络——一个没有中央控制且与“外部世界”没有连接的网络。 在 802.11 中，每个无线站必须与AP“联合（associate）才能发送和接收网络层数据。 当网络管理员安装AP时，管理员会分配一个字或两个字的服务集标识符（SSID）给接入点。（例如，在iPhone上的Wi-Fi设置下，会显示一个列表，其中显示范围内每个AP的SSID）管理员还必须分配一个通道号给AP。 802.11在2.4 GHz至2.4835 GHz的频率范围内工作。在85 MHz频带内，802.11定义了11个部分重叠的信道。任何两个通道都是不重叠的，当且仅当它们被四个或更多通道分开时。特别是，通道1、6和11的集合是三个非重叠通道的唯一集合。这意味着，管理员可以通过在同一物理位置安装三个802.11接入点，将信道1、6和11分配给接入点，并将每个接入点与交换机互连，创建一个总最大传输速率为表7.1所示最大传输速率三倍的无线局域网。 只有相”联合“的无线站和AP才会互相发送帧。 有一种情景叫做“WIFI丛林”有很多个AP在同一个物理地点。这个时候主机如何识别呢？ AP周期性地发送信标帧（beacon frames）包含AP的SSID和MAC地址。 扫描通道和侦听信标帧的过程称为被动扫描（见图7.9a）。无线设备还可以通过广播探测帧来执行主动扫描，该探测帧将由无线设备范围内的所有AP接收，如图7.9b所示。AP使用探测响应帧响应探测请求帧。然后，无线设备可以从响应的AP中选择要与之关联的AP。 连接AP需要认证，一些公司使用检查MAC的方法，咖啡馆使用用户名密码方法。AP都需要和认证服务器通信，使用RADIUS [RFC 2865] or DIAMETER [RFC 6733]协议。 The 802.11 MAC Protocol802.11 采用CSMA with collision avoidance （CSMA/CA）作为多路访问协议。 在以太网的语境下 CSMA 叫做“carrier sense multiple access” 意思是每个站感知一下隧道，然后再传输。尽管80211和以太网都用CSMA但是有一些重要区别。首先80211使用碰撞避免技术而不是碰撞探测技术。其次，因为无线通道误码率很高，802.11使用链路层确认/重传（ARQ）方案。 802.11不实现碰撞检测，有两个重要原因： 检测碰撞的能力要求能够同时发送（电台自身的信号）和接收（以确定另一个电台是否也在发射）。由于与802.11适配器处传输信号的强度相比，接收信号的强度通常非常小，因此构建能够检测冲突的硬件成本很高。 更重要的是，即使适配器可以同时传输和侦听（并且可能在检测到繁忙信道时中止传输），由于隐藏终端问题和衰落，适配器仍无法检测到所有冲突，如第7.2节所述。 802.11没有碰撞检测，因此它一旦开始发一个帧，就会整个传输该帧。为了避免大量碰撞，802.11采用一些碰撞避免策略。 先来看看链路层确认策略。当目的站接收到通过CRC的帧时，它等待一段称为短帧间隔（SIFS）的短时间，然后发回一个确认帧。如果发射站在给定的时间内没有收到确认，则它假设发生了错误，并使用CSMA/CA协议重新传输帧以访问信道。如果在一些固定次数的重新传输之后没有收到确认，则发射站放弃并丢弃该帧。 1.如果站点最初感觉到信道空闲，则在称为分布式帧间空间（DIFS）的短时间段后传输其帧；2.否则，站点使用二进制指数退避选择一个随机退避值（如我们在第6.3.2节中遇到的），并在检测到信道空闲时，在DIFS后对该值进行倒计时。当检测到信道忙时，计数器值保持冻结。3.当计数器达到零时（注意，只有在检测到信道空闲时，才会发生这种情况），站点传输整个帧，然后等待确认。4已在目的站正确接收。如果站点有另一个帧要发送，则在步骤2开始CSMA/CA协议。如果没有收到确认，则发射站在步骤2中重新进入退避阶段，随机值从较大的间隔中选择。 为什么即使感受到通道空闲，802.11仍然克制不传输呢（以太网协议不是这样的）？因为要尽量避免碰撞发生，在802.11下面，一旦发生碰撞，代价非常大（不停止传输）。 对付隐藏起来的终端：RTS 和 CTS 假想这样的情景：两个站互相隐藏，但对同一个AP不隐藏。 这样的话两个站无法感知另一站是否正在传输。为避免碰撞，站可以发送 Request to Send（RTS）控制帧和 Clear to Send（CTS）控制帧。当发送者想要发送数据帧时，先向AP发送RTS，表明预测总发送时间，AP再广播CTS，通知哪个站可以发，其他站静默。 也引入了延迟和消耗信道资源的问题，因此一般在DATA较长时使用。 802.11也可以点对点传输。 IEEE 802.11 帧帧的核心是有效载荷，它通常由IP数据报或ARP数据包组成。规定大小0-2312字节，一般小于1500字节。 包括32位循环冗余校验（CRC） 包含4个地址。前三个地址用于将网络层数据报从无线站通过AP移动到路由器接口。第四个用于点对点模式，这里不讨论。 地址2是传输帧的站点的MAC地址。因此，如果无线站发送该帧，则该站的MAC地址被插入地址2字段中。类似地，如果AP传输帧，则AP的MAC地址插入地址2字段。 地址1是要接收帧的无线站的MAC地址。因此，如果移动无线站发送该帧，则地址1包含目的AP的MAC地址。类似地，如果AP发送帧，则地址1包含目标无线站的MAC地址。 为了理解地址3，回想一下BSS（由AP和无线电台组成）是子网的一部分，该子网通过一些路由器接口连接到其他子网。地址3包含此路由器接口的MAC地址。 为了进一步了解地址3的用途，让我们在图7.14的背景下浏览一个互联网示例。在这个图中，有两个AP，每个AP负责多个无线电台。每个接入点都直接连接到路由器，路由器又连接到全球互联网。我们应该记住，AP是链路层设备，因此既不“讲”IP，也不理解IP地址。现在考虑将数据报从路由器接口R1移动到无线站H1。路由器不知道它和H1之间有AP；从路由器的角度来看，H1只是它（路由器）所连接的子网之一中的主机。 路由器知道H1的IP地址（从数据报的目标地址），使用ARP来确定H1的MAC地址，就像在普通以太局域网中一样。在获得H1的MAC地址后，路由器接口R1将数据报封装在以太网帧内。该帧的源地址字段包含R1的MAC地址，目标地址字段包含H1的MAC地址。•当以太网帧到达AP时，AP将802.3以太网帧转换为802.11帧，然后再将帧传输到无线信道。如上所述，AP分别用H1的MAC地址和它自己的MAC地址填充地址1和地址2。对于地址3，AP插入R1的MAC地址。通过这种方式，H1可以确定（从地址3）将数据报发送到子网的路由器接口的MAC地址。 序列数，持续时间，和帧控制字段。 序列数和tcp的那个类似 802.11允许传输站点保留通道一段时间，包括传输与确认的时间。存在“持续时间”里面 同IP子网内移动传输站C从BSS1移动到BSS2时，传输站检测到信号强度变化。发生BSS切换。交换机也收到特殊帧，调整forwarding table。 使用Global Positioning System (GPS) and the WiFi Positioning System (WPS)来定位 802.11高级特性传输速率控制功率管理（睡眠状态） 个人区域网络 蓝牙蜂窝网络：4G和5G","categories":[{"name":"计算机网络笔记","slug":"计算机网络笔记","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://example.com/tags/Network/"}]},{"title":"链路层","slug":"计算机网络笔记-5-链路层","date":"2022-04-12T15:59:06.000Z","updated":"2022-09-25T02:55:48.496Z","comments":true,"path":"2022/04/12/计算机网络笔记-5-链路层/","link":"","permalink":"http://example.com/2022/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-5-%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"","text":"Link Layer包是怎样在单个链路上传播的。有两种截然不同的链路层channel，一种是广播channel，一种是点到点交流链路 任何运行在链路层的设备都叫做node节点，包括主机，路由器，交换机，WiFi连接处。连接相邻节点的通道叫做链路。数据报被封装成为链路层帧。 链路层的工作便是把数据报从一个节点传输到相邻的节点，但是传输手段多种多样。 链路层可能提供以下服务： 组成帧。所有链路层协议都把数据报封装进帧然后再放进链接。帧包括头部以及数据部。 链接直达。medium access control（MAC）协议规定了数据报在在连接中的传输规则。 可靠传输。有的传输协议会保证可靠传输，（不拖到传输层和应用层处理）这在无线传输中可能很有必要，但是有线传输错误率并不高所以不常使用。 错误侦测和更正。在链路层的错误侦测通常更复杂，且在硬件中实现。 在大部分情况下，链路层在一块叫做network adapter网络适配器（也叫newwork interface controller（NIC））的芯片上实现。由此，许多链路层的功能是在硬件上实现的。例如因特尔700系列适配器实现了以太网协议。 Atheros AR5006实现了WiFi协议。 链路层控制器接过协议栈上层传递下来的数据报，包进链路层帧，然后传进链路。 链路层有些部分是在软件上实现的，一般是高一级的链路层功能，像是装配链路层地址信息，激活控制器硬件，处理错误，传数据报上网络层…链路层是协议栈里面硬件和软件相会之处。 错误探测和更正技术error-detection and -correction bits（EDC）与帧D被一起送往接收方，这时候EDC和D将可能变化。传输过程中错误并不是总能被发现。 下面有三种检测科技 Parity Checks使用单个的奇偶校验位。检测出是否发生奇数个比特错误。一般情况下同时出现多个比特错误的概率是很小的，错误通常爆发式出现，这时候探测到的概率就是百分之五十。如果把比特看为二维数组，并且每行每列都使用奇偶校验位，那么甚至能更正不严重的错误。 接收机检测和纠正错误的能力称为forward error correction（FEC）。 在需要速度的场合很有用。 checksumInternet校验和基于这种方法。字节数据被视为16位整数并求和。然后，该和的1s补码形成段标头中携带的Internet校验和。 在TCP和UDP协议中，对所有字段（包括标头和数据字段）计算Internet校验和。在IP中，校验和是通过IP头计算的（因为UDP或TCP段有自己的校验和）。在其他协议中，例如XTP【Strayer 1992】，在报头上计算一个校验和，在整个数据包上计算另一个校验和。 链路层使用循环冗余校验。由于传输层基于软件，所以需要有简单快速策略，而链路层的错误探测基于适配器的专用硬件，可以快速进行复杂的循环冗余校验。 Cyclic Redundancy Check (CRC)循环冗余校验 CRC码也叫多项式码，它将bit串视为系数为1与0的多项式，操作被解释为多项式算术。 模2算数：二进制加减乘除，不考虑加法的进位和减法的借位。加法和减法都等价于按位异或。 发送者和接收者共同约定一个除数。 被发送的帧必须扩展一部分。设除数r+1位，则将被发送的帧数据扩展r个0模2除除数，所得到的余数即为要扩展的部分（书里有数学推导）。 除数G是约定好了的。比如32位的：100000100110000010001110110110111 可以探测到少于r+1位的爆发式错误，大于r+1的有1-0.5^r的概率探测到，可以探测到奇数位错误。 数学证明不在讨论之列。 Multiple Access Links and Protocols 有两种网络链路：点到点链路和广播链路。 point-to-point protocol（PPP）和high-level data link control（HDLC）是为点到点链路设计的协议。 广播链路可以有很多发送端和接收端，连接到共享的广播通道上。一个节点发送了帧，其他的被链接的节点都会收到这个帧。 Ethernet 和 wireless LANs都是广播技术的例子。 本节不讨论具体协议，先解决关键问题：协调多个发送和接收节点对共享广播信道的访问——多访问问题。 碰撞：多于两个节点同时发出帧时，这些帧都会丢失。 有许多工作都是为了解决 multiple access protocol问题的。 有很多multiple access protocol，可归为三类： channel partitioning protocols random access protocols taking-turns protocols 多址接入协议应该有这些特征：（速率为每秒R比特的广播频道）1、当只有一个节点有数据要发送时，该节点的吞吐量为R bps。2、当M个节点有数据要发送时，每个节点的吞吐量为R/M bps。这不一定意味着M个节点中的每个节点总是具有R/M的瞬时速率，而是每个节点应该在一些适当定义的时间间隔上具有R/M的平均传输速率。3、协议分散；也就是说，here is no master node that represents a single point of failure for the network.4、协议简单，实现成本低廉。 Channel Partitioning Protocols 通道分割 时分复用（TDM）绝对公平地为每个节点提供了相同地可发送时间。但有两个缺点：即使只有一个节点需要传输，它也只能在自己的时间范围内传输；节点必须遵守传输顺序。 频分复用（FDM）具有与时分复用相同的特点。 码分多址（code division multiple access）（CDMA）为每个节点安排一个码值，每个节点使用独特的码值来编码它所发送的数据。如果码值选得很好，不同的节点可以同时传输，使他们各自的接收者都接收到。 随机访问协议 每个节点都全力传输数据，出现碰撞时，参与进碰撞的节点都会独立等待一段随机延迟再重复传输。 很多协议使用这种策略。ALOHA协议使用这种策略。carrier sense multiple access protocol（CSMA）（载波侦听多路访问协议）使用这种策略，以太网使用CSMA。 slotted ALOHA 做以下假设：时间被分为一段一段槽，帧能在一段槽里被传完，所有节点能知道碰撞发生了。 于是节点的行为是这样的： 当节点有一个新的帧要发送时，它会等待到下一个时隙的开始，并在该时隙中传输整个帧。 如果没有冲突，则节点已成功传输其帧，因此无需考虑重新传输帧。（如果节点有新帧，则可以为传输准备新帧。） 如果发生冲突，节点会在插槽结束之前检测到冲突。节点在每个后续时隙中以概率p重新传输其帧，直到帧在没有冲突的情况下传输。 优点： 允许持续全速传输。 去中心化。 但是有很多节点时冲突问题很严重。 ALOHA仍然规定了传输时间t，但是这次发送帧不会同步。 很多节点时效率是slotted ALOHA的一半。 Carrier Sense Multiple Access (CSMA) carrier sensing载波感应，节点在传输之前会监听通道，如果探测到传输消失，过一小段时间后会开始传输。collision detection碰撞检测，正在传输的节点监听通道，如果出现碰撞则立即停止传输，随机等待一段时间后重新开始监听。 这两个规则体现在载波侦听多址（CSMA）和带冲突检测的CSMA（CSMA/CD）协议系列中 比特在通道里传播的时间越长，就越有可能发生碰撞，因为其他节点可能误以为此时没有节点在传输。 Carrier Sense Multiple Access with Collision Detection (CSMA/CD) 带冲突检测的载波侦听多址接入（CSMA/CD） 这是适配器的行为：1、适配器从网络层获取数据报，准备链路层帧，并放置帧适配器缓冲区。2、如果适配器检测到信道空闲（即，没有信号能量从信道进入适配器），它将开始传输帧。另一方面，如果适配器检测到信道正忙，它将等待，直到检测到没有信号能量，然后开始传输帧。3、传输时，适配器使用广播频道监视是否存在来自其他适配器的信号能量。4、如果适配器传输整个帧而未检测到来自其他适配器的信号能量，则适配器完成帧的传输。另一方面，如果适配器在传输时检测到来自其他适配器的信号能量，它将中止传输（即停止传输其帧）。5、中止后，适配器随机等待一段时间，然后返回步骤2。 如何选择碰撞后的等待时间呢？binary exponential backoff algorithm二进制指数退避算法解决了这一问题。Ethernet和NOCSIS线缆网络多址协议使用了它。 具体地，当传输已经经历n次碰撞的帧时，节点从{0,1,2，….2n-1}中随机选择K的值。因此，帧经历的碰撞越多，从中选择K的间隔就越大。对于以太网，节点等待的实际时间量是K*512位的倍（即，将512位发送到以太网所需的时间量的K倍），并且n可以接受的最大值被限制为10。 Taking-Turns Protocols 理想的协议有这样的特点：1.当只有一个节点活动时，满效率。2.当M个节点活动时，效率均分。ALOHA和CSMA有第一条特性，但是没有第二条。接下来介绍的轮流协议可以做到两条。 polling protocol轮询协议一个节点被设计成主节点。主节点以循环方式轮询每个节点，给予每个节点发送帧的机会。 缺点： 轮询延迟 如果主节点失效了，整个通道都会失效。 蓝牙协议使用polling protocol token-passing protocol令牌传递协议一个小型的，特殊用途的帧，叫做令牌在节点间传送，以一种固定顺序（即节点一总是会给节点二，节点二给三）。当一个节点拿到令牌后，如果有帧要送就抓住，直到送完或者到达一次允许的最大传输帧数，如果没有就把令牌送出去。 缺点：一个节点失效了，整个通道都会失效。若节点拒绝释放令牌，还需要一些恢复过程介入。 DOCSIS：有线互联网接入的链路层协议 线缆接入网络一般都链接了几千居民线缆调制解调器到电缆调制解调器终端系统 (CMTS)上。Data-Over-Cable Service Interface Specifications (DOCSIS) （有线数据服务接口规范）指定了电缆数据网络体系结构及其协议。 使用FDM分割下行与上行段，到多个频段。下行频道在24MHz与192MHz之间，最大传输1.6Gbps，上行6.4MHz到96MHz，最大1Gbps。每个上下行通道都是广播通道。下行通道只有CMTS一个节点传输，没有多路访问问题。 每个上行信道被划分为时间间隔（类似TDM），每个时间间隔包含一系列小时隙，在此期间，电缆调制解调器可以传输到CMT。CMTS明确授予独立电缆调制解调器在特定迷你插槽期间传输的权限。CMTS通过在下游通道上发送称为MAP消息的控制消息来实现这一点，以指定在控制消息中指定的时间间隔内，哪个电缆调制解调器（带有要发送的数据）可以在哪个小时隙期间传输。由于小时隙被明确分配给电缆调制解调器，CMT可以确保在小时隙期间没有冲突传输。 但CMT如何知道哪些电缆调制解调器首先要发送数据？这是通过让电缆调制解调器在专用于此目的的一组特殊间隔迷你插槽期间向CMT发送迷你插槽请求帧来实现的，这些小时隙请求帧以随机访问方式传输，因此可能相互冲突。电缆调制解调器既不能检测上游信道是否繁忙，也不能检测冲突。相反，如果在下一条下游控制消息中未收到对请求分配的响应，电缆调制解调器推断其迷你插槽请求帧发生冲突。当推断出冲突时，电缆调制解调器使用二进制指数延迟，并重发。当链路里没有什么上行交通时，线缆调制解调器可能会在名义上分配给迷你槽请求的帧上传递数据帧，以避免等待迷你帧分配。 Switched Local Area Networks 交换机在链路层工作，他们switch链路层的帧而不是网络层的数据报，它们不认IP，不用OSPF。 Link-Layer Addressing 和 ARP 主机和路由器拥有链路层地址，（同时有网络层地址），为什么需要有两个地址呢？这一节将给出答案。 MAC地址事实上不是主机和路由器有链路层地址，而是适配器（网络接口）有链路层地址。一个主机如果有多个适配器，那它将有多个链路层地址，就像有多个IP地址一样。 但是链路层交换机没有链路层地址。因为它的工作只是在主机和路由器两者之间携带数据报。这份工作是透明的，发送者不必将帧定向寻址到交换机。 链路层地址可以叫做LAN（局域网）地址、物理地址、MAC地址。MAC地址叫得最多。对大多数局域网（包括以太网、802.11无线局域网）MAC地址6字节长（2^48个）经常表示为16进制。尽管现在已经可以用软件改变MAC地址，但是我们假定MAC地址固定。 MAC地址不重复，IEEE管理MAC地址空间。 适配器的MAC地址自生产出来即固定。 当一个适配器想送一个帧到一些目标适配器时，发送者适配器把目标MAC地址嵌入帧，然后发到局域网里面。如果适配器收到目标不是其MAC地址的帧，它会丢弃。 广播地址，所有适配器都会接受：FFFFFFFFFFFF 为什么主机和路由器需要有两层地址？ LAN是为任意网络层协议设计的，不仅仅是IP和互联网。网络层除了IP以外还有其他协议比如说IPX、DECnet。LAN需要保持中立。 如果适配器用网络层地址，那么就需要反复重新配置。 此外，如果链路层没有自己的地址，把所有帧都发给网络层处理，那么会被打扰得很厉害，因为会收到在LAN中被广播的无关帧 学到这里已经有三种地址了：应用层的主机名（指DNS服务），网络层的IP，链路层的MAC Address Resolution Protocol (ARP) 以下讨论作这样的假设：交换机将广播所有的帧。 使用ARP可以通过本LAN的IP地址来查询MAC地址。主机里的ARP模块接收IP地址返回对应的MAC地址。 再次强调：ARP只解析与当前主机和路由器接口处于同一子网的IP地址。 每台主机和路由器都有ARP表（内存中），放着IP和ARP映射关系。还有一条time-to-live值（TTL）表示这条映射将在什么时候被删除。这张表并不需要包含所有主机与路由器。一般的到期时间是20分钟。 如果表里没有想要的映射条目，就需要构造ARP包，包里面包含发送端与接收端IP和MAC地址（查询时广播FFFFFFFFFFFF），查询与回复具有相同格式。查询包将会查询当前子网的所有设备。 接收端ARP模块发现接收到的ARP包的目标地址和自己的IP地址相同，相同的话就送回包含着所需映射的ARP包（非FFFFFFFFFFFF广播帧）。 接下来讨论发出子网的情况。 （记住路由器的每个端口都有一个IP地址和一个MAC地址。） 发送者先会将数据报写上目标地址，帧上却写路由器地址，发给路由器。路由器使用网络层协议（forwarding table使用）确定数据报要往哪里发。 Ethernet以太网 以太网是目前最流行的有线LAN技术。 最初的以太网LAN是由Bob Metcalfe和David Boggs在20世纪70年代中期发明的。最初的以太网LAN使用同轴总线互连节点。以太网总线拓扑实际上在整个20世纪80年代和90年代中期一直存在。具有总线拓扑的以太网是一个广播LAN，所有传输的帧都传输到总线上，并由连接到总线的所有适配器处理。 90年代末，大多数公司和大学把他们的LAN换成了使用基于中心（hub）的星形拓扑结构的以太网。中心使用物理层设备，收到一个比特后单纯地放大它，然后送给所有相连的节点。 2000早期，以太网获得巨大改进，现在中心的物理层设备换成了交换机。这个交换机“碰撞少”、“善良”、“存储并转发”。 以太网帧 前导码（Preamble）（8字节），前七个字节是10101010，最后一个是10101011。前七个字节用于叫醒接收者适配器，同步接收者的时钟。最后两个比特告诉接收者重要的东西来了 目标地址（6字节）（MAC地址） 源地址（6字节）（MAC地址） 类型域（2字节），载荷里面可以装其他类型的网络层协议，不只是IP。此外，ARP协议有它自己的类型数字。与网络层数据报的协议域和传输层段的端口数字域相类似，这些域犹如胶水将下层与上层的协议粘起来。 数据域（46到1500字节）装着IP数据报 循环冗余校验码（4字节） 以太网是“无连接”的，如同IP和UDP一样。 以太网是“不可靠”的，接收者发现报文错误之后只是简单地丢掉它。发送者不知道报文被丢弃了或者是没有送到。（当然如果上层有TCP的话，TCP会重发） 以太网技术历史上以太网使用同轴电缆，只需将电缆们连在一起，局域网就完成了。 现在节点连在交换机上，用双绞铜线或光纤。 mid-1990s 100Mbps以太网被标准化，十倍于之前。 40Gigabit Ethernet凭借着已经装配好的巨量以太网设施，具有巨大的潜能，它的标准包括以下这些： 使用标准以太网帧，这可以追溯到10Mbps时代。 允许点到点。在Gigabit 以太网级别的行话里，中心（hub）叫做有缓存的分配者（buffered distributors） 用CSMA/CD来分享广播通道。为了拥有可接受的效率，节点之间的最大距离必须被限制。 允许在点到点通道的两个方向上以40 Gbps的速度进行全双工操作 下一节将学习交换机，现代交换机是全双工的（full-duplex）不会有碰撞，即使两个节点之间互相传播。所以MAC协议实际上不需要了。 有了这么大的改变，以太网帧的格式始终没有变，以太网仍然是以太网。 链路层交换机交换机的职责是接收传入的链路层帧，将它们转发到出口链路。交换机对于节点们来说是透明的（就好像链路上根本没有这台机器一样）。交换机拥有出口（output interface）缓冲区（buffer），来应对流量突然增大超出链路传输能力的情况。 转发与过滤过滤功能是来决定帧是被转发进接口，或者是被丢弃。转发功能是决定一个包应被发往哪些接口。 这两个功能是根据转发表来完成的。转发表条目中包含一些（并不一定所有）主机和路由器。条目包含：一个MAC地址，导向那个地址的交换机接口，这条条目放进表的时间。 （在第四章网络层中我们认识到很多现代的包交换机（packet switch）可以被配置成基于MAC或IP进行转发） 接收到发来的帧时，链路层交换机具有这样的行为： 如果帧上写的目标地址不在表中，就把它发给除了接收链路接口之外的所有接口。 如果在表中，就把帧装到对应接口的缓冲区。 自学习交换机的表格是自动构建的，动态的，自治的。以下是它的行为： 交换机表（switch table）初始为空 每收到一个帧，交换机就会组合“源MAC”地址、接口号、现在时间来组合成条目插到表里面去。 如果一段时间内（the aging time）某个地址没有发来帧，交换机会把条目删去。 交换机是即插即用的设备，它们不需要用户或管理员的干预。 交换机是全双工的，每个接口都能同时收发。 交换机可以消灭掉碰撞。交换机 会把帧缓存起来，每次不会同时传输超过一个帧。因为交换机的效率是所有接口的效率相加，因此相比于hub或者粗暴链接，使用交换机的LAN获得了相当大的性能提升。 异质链路。交换机将链路们分开了，不同速的链路可以在同一个LAN下工作。这保证了兼容旧设备。 管理。交换机提供了强化的安全，也可以减轻网络的管理负担。比方说交换机可以发现某个一直在发帧的出了问题的适配器，然后断掉它的链接。交换机也会收集带宽使用、碰撞率、交通类型的统计信息，呈给管理人员看。 交换机 vs 路由器传统上，路由器基于第三层，用网络层地址；交换机基于第二层，用MAC地址。然而第4章学到的现代交换机使用“匹配加动作”可以转发第二层的帧。使用广义转发的交换机可以使用帧头部、数据报头部、传输层头部的11个域中的一些完成转发。 首先考虑交换机的利弊。如上所述，交换机是即插即用的，交换机也可以具有相对较高的过滤和转发速率，交换机只能处理到第2层的帧，而路由器必须处理到第3层的数据报。另一方面，为了防止广播帧的循环，交换网络的活动拓扑被限制为生成树。此外，大型交换网络将需要主机和路由器中的大型ARP表，并将产生大量ARP流量和处理。此外，交换机容易受到广播风暴的影响。如果一台主机失控并传输源源不断的以太网广播帧，交换机将转发所有这些帧，导致整个网络崩溃。 现在考虑一下路由器的优缺点。由于网络寻址通常是分层的（而不是像MAC寻址那样平坦），所以即使网络有冗余路径，数据包通常也不会在路由器中循环。（然而，当路由器表配置错误时，数据包可能会循环；但正如我们在第4章中了解到的，IP使用一个特殊的数据报头字段来限制循环。）因此，数据包不限于生成树，可以使用源和目标之间的最佳路径。因为路由器没有生成树的限制，所以它们允许互联网具有丰富的拓扑结构，例如，包括欧洲和北美之间的多个活动链接。路由器的另一个特点是，它们提供防火墙保护，防止第二层广播风暴。不过，路由器最显著的缺点可能是它们不是即插即用的，它们和连接到它们的主机需要配置它们的IP地址。此外，路由器通常比交换机具有更大的每包处理时间，因为它们必须通过第3层字段进行处理。最后，单词router有两种不同的发音方式，要么是“rootor”要么是“rowter”，人们会浪费大量时间争论正确的发音。 一般来说，几百台主机的小型网络，有几个LAN部分。对于这些小型网络，交换机足够了。大一点的网络就需要包含路由器了。路由器提供更健壮的交通隔离，使用更聪明的路径。 虚拟局域网（VLANs） 某个机构的局域网们可能会被设置成这样：每个部门有自己的局域网，交换机。交换机通过层级结构连接。这种配置方式有缺陷： 缺少交通隔离。携带广播地址或者未被交换机识别的地址的帧会被传遍整个机构网络。隐私需要被保护。 低效率使用。单个团体，主机较少时不划算。把这些团体放到一个LAN里又会无法隔离。 管理使用者。员工挪动工作团队，或者跨团队很难管理。 支持VLAN的交换机则可以解决这些问题。交换机的端口（接口）们被管理员分成了几组，每组都构成一个VLAN。交换机的硬件将只为同一个VLAN内的主机传输帧。 如果两个VLAN要通信，可以拉一个端口出来接到路由器上，配置这个端口同时属于两个VLAN。 VLAN中继是一个互联VLAN交换机的很好方法，每个交换机都有一个特别端口，被配置成为中继端口。中继端口属于所有VLAN。有以太网帧格式扩展以解决获知VLAN源头的问题。在发送方VLAN中继接口处，报文头部加上了4字节VLAN tag，包含2字节标记协议标识符（TPID）字段（固定十六进制值为81-00）、包含12位VLAN标识符字段的2字节标记控制信息字段，和与IP数据报TOS字段类似的3位优先级字段。 虚拟局域网还有很多种不同的实现方法。 Link Virtualization:A Network as a Link LAyer 由于本章涉及链路层协议，并且鉴于我们现在接近本章的结尾，反思一下我们对术语链路的理解是如何演变的，我们在本章开始时将链路视为连接两个通信主机的物理导线。在研究多址协议时，我们发现，多个主机可以通过共享电线连接，而连接主机的“电线”可以是无线电频谱或其他媒体。这使我们更抽象地将链接视为一个通道，而不是一条电线。在我们对以太网LAN的研究中我们看到，互连介质实际上可能是一个相当复杂的交换基础设施。在整个进化过程中。然而主机本身认为互连介质只是连接两个或多个主机的链路层通道。例如，我们看到，一个以太网主机可以很幸运地不知道它是通过一个短LAN组件还是通过地理位置分散的交换LAN（图6）连接到其他LAN主机或通过VLAN。 使用拨号调制解调器，主机由电话网络连接（是逻辑上分隔的，有自己的一套东西）。然而链路层仍然能将电话网络看作链路层科技，连接两台主机（互联网的虚拟化）。 本节考虑Multiprotocol Label Switching（MPLS）网络。 建立目的：通过有选择地标记数据报，并允许路由器在可能的情况下根据固定长度的标签（而不是目标IP地址）转发数据报来增强IP数据报转发基础设施。 MPLS头被插在23层的头之间。 MPLS只能在具备MPLS处理能力的路由器之间传播（常被称为“标签switched路由器）。路由器查看其路由表里的MPLS标签然后立即把数据报放到合适的接口。它不需要查看IP和对照转发表了。 MPLS可以用于构建virtual private networks。 Data Center Networking 数据中心不仅与互联网相连，而且内部也包含了复杂的网络，叫做数据中心网络。 本节探讨为云应用的数据中心网络。 数据中心有三大功能：提供内容，为特殊数据处理任务充当大量并行计算基础设施，提供云计算服务。 现在的公司倾向于使用云提供者来满足基本上所有的IT需求。 数据中心里的主机叫做blades，拥有CPU内存和磁盘存储。这些主机被码放在架子上，每个架子上放20到40个。每个架子顶端有一台交换机叫做Top of Rack switch，连接这台架子上的主机和其他交换机。每台主机都配上了数据中心内部的IP地址。 为应对外部内部之间的交通，网络中包含边界路由器，连接数据中心网络和外界互联网。 外部发来请求，数据中心会将它导引到负载均衡器。它的任务是把请求分配到主机。它也具有NAT功能，避免外界与主机直接连接 层级结构。对于一个只有几千台主机的小型数据中心，一个由边界路由器、负载平衡器和几十个机架组成的简单网络可能就足够了，所有机架都由一个以太网交换机互连。但为了扩展到数万到几十万台主机，数据中心通常采用路由器和交换机的层次结构。在层次结构的顶部，边界路由器连接到访问路由器。在每个接入路由器下面，有三层交换机。每个接入路由器连接到一个顶层交换机，每个顶层交换机连接到多个第二层交换机和一个负载平衡器。每个第二层交换机依次通过机架或交换机（第三层交换机）连接到多个机架。所有链路通常使用以太网作为其链路层和物理层协议，并混合使用铜缆和光纤布线。通过这种分层设计，可以将数据中心扩展到数十万台主机。 存在主机之间交流的问题，比如TOR交换机允许100Mbps，同时有40个不同架子上的主机互相通信，这样效率就低了。解决方法：使用更先进的交换机和路由器（但很贵）。这个问题的第二个解决方案是尽可能地将相关服务和数据放在一起（例如，在同一个机架或附近的机架中），只要有可能就可以采用；以尽量减少通过tier-2或tier-1交换机的机架间通信。但这只能满足数据中心的一个关键要求，即计算和服务的灵活性。例如，大型互联网搜索引擎可以在分布在多个机架上的数千台主机上运行，所有主机对之间的带宽要求都很高。类似地，云计算服务（如Amazon Web Services或Microsoft Azure）可能希望将包含客户服务的多个虚拟机放置在容量最大的物理主机上，而不考虑其在数据中心的位置。如果这些物理主机分布在多个机架上，如上所述的网络瓶颈可能会导致性能不佳。 该解决方案的最后一部分是增加TOR交换机和tier-2交换机之间的连接。以及第2层交换机和第1层交换机之间。例如，每个TOR交换机可以连接到两个tier-2交换机，然后在机架之间提供多条链路和交换机不相交的路径。第一个tier-2交换机和第二个tier-2交换机之间有四条不同的路径，共同提供了前两个tier-2交换机之间400 Gbps的总容量。增加层之间的连接度有两个显著的好处：交换机之间的容量增加，可靠性提高（因为路径多样性）。每个TOR连接到四个不同的tier-2交换机。每个tier-2交换机连接到四个不同的tier-1交换机。 未来趋势 减少代价集中式SDN控制和管理虚拟化物理约束硬件模块化和定制 回顾：网页请求协议栈的旅途已经走完了，现在来总结一下。模拟电脑是如何获取网页的。 P523 6总结在本章中，研究了链路层及其服务、其运行的基本原则，以及在实现链路层服务时使用这些原则的一些重要特定协议。 我们看到，链路层的基本服务是将网络层数据报从一个节点（主机、交换机、路由器、接入点）移动到相邻节点。我们看到，所有链路层协议都是通过将网络层数据报封装在链路层帧中，然后再通过链路将帧传输到相邻节点来运行的。然而，除了这个常见的帧功能之外，我们还了解到，不同的链路层协议提供非常不同的链路访问、传递和传输服务。这些差异部分是由于链路层协议必须在各种各样的链路类型上运行。简单的点到点链路有一个发送方和接收方通过一根“线”进行通信。多个发送方和接收方共享一条多址链路：因此，多址信道的链路层协议有一个用于协调链路访问的协议（其多址协议）。在MPLS的情况下，连接两个相邻节点的“链路”（例如，在IP意义上相邻的两个IP路由器，它们是朝向某个目的地的下一跳IP路由器）实际上可能是其自身的。从某种意义上讲，将网络视为链接的想法应该不会显得奇怪。例如，将家庭调制解调器/计算机连接到远程调制解调器/路由器的电话链路实际上是一条通过复杂电话网络的路径。 在链路层通信的基本原理中，我们研究了错误检测和纠正技术、多址协议、链路层地址、虚拟化（VLAN）以及扩展交换LAN和dala中心网络的构建。目前，链路层的主要关注点是这些交换网络。在错误检测/纠正的情况下，我们研究了如何向帧的头部添加额外的位，以便检测并在某些情况下纠正在通过链路传输帧时可能发生的位翻转错误。我们介绍了简单的奇偶校验和校验和方案，以及更健壮的循环冗余校验。然后我们转到多址协议的主题。我们确定并研究了三种协调广播信道访问的广泛方法：信道划分方法（TDM、FDM）、随机访问方法（ALOHA协议和CSMA协议）和turs方法（轮询和令牌传递）。我们研究了有线接入网，发现它使用了许多这些多址方法。我们发现，让多个节点共享一个广播频道的结果是需要在链路层提供节点地址。我们了解到链路层地址与网络层地址有很大不同，在互联网的情况下，使用一种特殊的协议（ARP地址解析协议）在这两种寻址形式之间进行转换，并详细研究了非常成功的以太网协议。然后，我们研究了共享广播频道的节点如何形成LAN，以及如何将多个LAN连接在一起以形成更大的LAN—所有这些都无需干预网络层路由，以互连这些本地节点。我们还了解了如何在单个物理LAN基础设施上创建多个虚拟LAN 我们结束了对链路层的研究，重点介绍了MPLS网络在互连IP路由器时如何提供链路层服务，并概述了当今大规模数据中心的网络设计。我们通过确定获取一个简单网页所需的许多协议来结束本章（以及前五章）。在覆盖了链接层之后，我们的职业生涯现在结束了！当然，物理层位于链接层之下，但物理层的细节可能最好留给另一门课程（例如，在通信理论中，而不是在计算机网络中）。然而，我们在本章和第一章（我们在第1.2节中对物理介质的讨论）中涉及了物理层的几个方面。在下一章研究无线链路特性时，我们将再次考虑物理层。 虽然我们的协议栈之旅已经结束，但我们对计算机网络的研究还没有结束。在接下来的三章中，我们将介绍无线网络、网络安全和多媒体网络。这四个主题不适合任何一个层次；事实上，每个主题都跨越了许多层面。因此，理解这些主题（在某些网络文本中被称为高级主题）需要在协议栈的所有层都有一个坚实的基础——我们对链接层的研究现在已经完成了！","categories":[{"name":"计算机网络笔记","slug":"计算机网络笔记","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://example.com/tags/Network/"}]},{"title":"创建子类模型","slug":"Qt文档译注-1-创建子类模型","date":"2022-04-12T15:55:43.000Z","updated":"2022-09-22T15:36:21.304Z","comments":true,"path":"2022/04/12/Qt文档译注-1-创建子类模型/","link":"","permalink":"http://example.com/2022/04/12/Qt%E6%96%87%E6%A1%A3%E8%AF%91%E6%B3%A8-1-%E5%88%9B%E5%BB%BA%E5%AD%90%E7%B1%BB%E6%A8%A1%E5%9E%8B/","excerpt":"子类模型需要提供 QabstractemModel 基类中定义的许多虚函数的实现。需要实现的函数数量取决于模型的类型——它是为视图提供简单的列表、表格还是复杂的项目层次结构。从 QAbstractListModel 和 QAbstractTableModel 继承的模型可以利用它们所提供函数的默认实现。以树状结构组织数据项的模型必须为QabstractemModel中的许多虚函数提供实现。","text":"子类模型需要提供 QabstractemModel 基类中定义的许多虚函数的实现。需要实现的函数数量取决于模型的类型——它是为视图提供简单的列表、表格还是复杂的项目层次结构。从 QAbstractListModel 和 QAbstractTableModel 继承的模型可以利用它们所提供函数的默认实现。以树状结构组织数据项的模型必须为QabstractemModel中的许多虚函数提供实现。 需要在模型子类中实现的功能可分为三组： 数据项处理：所有模型都需要实现功能，以使视图和委托能够查询模型的维度、检查项目和检索数据。 导引和索引创建：具有层次结构的模型需要提供视图可以调用的功能，以导引它们展示的树状结构；以及获取项的索引。 拖放支持和MIME类型处理：模型继承了控制内部和外部拖放操作的函数。这些函数允许按照其他组件和应用程序可以理解的MIME类型来描述数据项。 数据项处理模型可以提供对其提供的数据项的不同访问级别：它们可以是简单的只读项，或者能支持调整大小操作，有的甚至允许编辑。 只读权限如果模型提供的数据项是只读的，在子类中这些函数需要被实现： flags() 其他组件用于获取有关模型提供的每个项目的信息的标志在许多模型中，标志的组合应该包括Qt：：ItemIsEnabled和Qt：：ItemIsSelectable。 data() 用于向视图和委托提供项数据。通常，模型只需要为Qt：：DisplayRole和用户特定的角色(role)提供数据，但为Qt：：ToolTipRole、Qt：：AccessibleTextRole和Qt：：AccessibleDescriptionRole提供数据也是一种很好的做法。有关与每个角色关联的类型的信息，请参阅Qt：：ItemDataRole枚举文档。 headerData() 为视图提供要在其标头中显示的信息。该信息仅由可以显示标头信息的视图检索。 rowCount() 模型提供的数据行数 这四个函数必须在所有类型的模型中实现，包括列表模型（QAbstractListModel 子类）和表模型（QAbstractTableModel 子类）。 此外，必须在QAbstractTableModel和QAbstractItemModel的直接子类中实现以下功能： columnCount() 模型提供的数据列数。列表模型不提供此功能，因为它已在QAbstractListModel中实现。 可编辑数据项可编辑模型允许修改数据项，并可能提供允许插入和删除行和列的功能。要启用编辑，必须实现下列函数： flags() 必须为每个项目返回适当的标志(flag)组合。特别的，除了应用于只读模型中的项的值之外，此函数返回的值还必须包括Qt：：ItemIsEditable。 setData() 用于修改与指定模型索引关联的数据项。为了能够接受用户界面元素提供的用户输入，此函数必须处理与Qt：：EditRole关联的数据。该实现还可以接受与Qt：：ItemDataRole指定的许多不同类型的角色相关联的数据。更改数据项后，模型必须发出dataChanged（）信号，以通知其他组件该更改。 setHeaderData() 用于修改水平和垂直标头信息。更改数据项后，模型必须发出headerDataChanged（）信号，以通知其他组件该更改。 可变容量模型所有类型的模型都可以支持插入和删除行。表模型和层次模型还可以支持插入和删除列。而在模型尺寸发生更改之前和之后，要将更改通知给其他组件。因此，可实现以下函数以允许调整模型的容量，但这些函数的实现必须确保适当的函数被调用以通知与这个模型相连接的视图和委托： insertRows 用于向模型中添加新行和数据项。注意必须在插入操作之前调用beginInsertRows（），插入完成后立即调用endInsertRows（）。 removeRows 用于从所有类型的模型中删除行及其包含的数据项。在删除行之前，必须调用beginRemoveRows（），完成后立即调用endRemoveRows（）。 insertColumns 用于向模型中添加新列和数据项。注意必须在插入操作之前调用beginInsertColumns（），插入完成后立即调用endInsertColumns（）。 removeColumns 用于从所有类型的模型中删除列及其包含的数据项。在删除行之前，必须调用beginRemoveColumns（），完成后立即调用endRemoveColumns（）。 通常，如果操作成功，这些函数应返回true。然而，可能存在操作仅部分成功的情况；例如，可以插入的行数小于指定的行数。在这种情况下，模型应返回false以表示操作失败并指示相关组件处理这种情况。 在调整容量API的实现中调用函数发出的信号使相关的组件有机会在某些数据不可用之前采取行动。使用begin和end函数封装insert和remove操作，还可以使模型正确管理持久模型索引。 通常，begin和end函数能够通知其他组件模型底层结构的更改。对于模型结构的更复杂更改，可能涉及内部重组、数据排序或任何其他结构更改，有必要按顺序执行以下操作： 发出layoutAboutToBeChanged（）信号 更新表示模型结构的内部数据。 使用changePersistentIndexList（）更新持久索引 发出layoutChanged（）信号。 此序列可用于任何结构更新，是一种更高级和更方便的保护方法。例如，如果一个有200万行的模型需要删除所有奇数行，即有100万个长度为1的裁剪范围。可以使用beginRemoveRows和endRemoveRows 100万次，但这显然效率低下。相反，这可以视作一个布局更改来发出信号，它会立即更新所有必要的持久性索引。 模型数据的惰性填充模型数据的惰性填充有效地延迟对模型信息的请求，直到视图实际需要它为止。 一些模型需要从远程源获取数据，或者必须执行耗时的操作以获取有关数据组织方式的信息。由于视图通常要求尽可能多的信息以准确显示模型数据，因此限制返回给它们的信息量以减少不必要的后续数据请求可能会很有用。 在层次模型中，查找给定项的子项数量是一项代价高昂的操作，因此确保仅在必要时调用模型的rowCount（）非常有用。在这种情况下，可以重新实现hasChildren（）函数，为视图提供一种廉价的方法来检查子项的存在，对于QTreeView，draw the appropriate decoration for their parent item. 无论hasChildren（）的重新实现是否返回true或false，视图都可能不需要调用rowCount（）来确定存在多少子级。例如，如果父项未展开以显示子项，则QTreeView不需要知道有多少子项。 如果知道许多项都有子项，那么重新实现hasChildren（）以无条件返回true有时是一种有用的方法。这使得检查每个数据项子项的操作被推迟到之后进行，同时使模型数据的初始总体尽可能快。唯一的缺点是，没有子项的数据项可能在某些视图中显示不正确，直到用户尝试查看这些数据项。 导航(Navigation)和模型索引创建层次模型需要提供函数以导航它们公开的树状结构，供视图调用，并让视图可以获取项的索引。 父级和子级由于暴露给视图的结构由底层数据结构决定，因此每个模型子类都可以通过提供以下函数的实现来创建自己的模型索引： index 给定父项的模型索引，此函数允许视图和委托访问该项的子项。如果找不到与指定的行、列和父模型索引相对应的有效子项，则函数必须返回QModelIndex（），这是一个无效的模型索引。 parent 提供与任何给定子项的父项相对应的模型索引。如果指定的模型索引对应于模型中的顶级项，或者如果模型中没有有效的父项，则函数必须返回使用空QModelIndex（）构造函数创建的无效模型索引。 上述两个函数都使用createIndex（）工厂函数来生成索引，供其他组件使用。模型通常会向该函数提供一些唯一标识符，以确保模型索引稍后可以与其相应的项重新关联。 拖放支持和MIME类型处理模型/视图类支持拖放操作，提供了许多应用程序所需的默认行为。但是，也可以自定义项目在拖放操作期间的编码方式，默认情况下是复制还是移动数据项，以及如何将数据项插入现有模型。 此外，方便视图类（convenience view）实现了专门的行为，这些行为应该严格遵循现有开发人员的预期。“方便视图”部分提供了此行为的概述。 MIME数据默认情况下，内置模型和视图使用内部MIME类型（application/x-QAbstracteModelDataList）传递有关模型索引的信息。这将指定数据项列表的数据，其中包含每个项目的行号和列号，以及关于每个项目支持的角色的信息。 使用此MIME类型编码的数据可以通过使用包含要序列化的项的QModelIndexList调用QAbstractItemModel：：mimeData（）来获得。 在自定义模型中实现拖放支持时，可以通过重新实现以下函数以专用格式导出数据项： mimeData 此函数可以重写，以非默认application/x-qabstractemodeldatalist内部MIME类型的格式返回数据。子类可以从基类获得默认的QMimeData对象，并以其他格式向其添加数据。 对于许多模型，以MIME类型（如text/plain和image/png）表示的通用格式提供项目的内容非常有用。请注意，可以使用QMimeData：：setImageData（）、QMimeData：：setColorData（）和QMimeData：：setHtml（）函数轻松地将图像、颜色和HTML文档添加到QMimeData对象中。 接受拖放数据在视图上执行拖放操作时，将查询基础模型，以确定其支持的操作类型以及可以接受的MIME类型。此信息由qabstractemmodel：：supportedDropActions（）和qabstractemmodel：：mimeTypes（）函数提供。不重写QAbstractItemModel提供的实现的模型支持复制操作和项的默认内部MIME类型。 将序列化的项数据放到视图中时，将使用QabstractemModel：：dropMimeData（）的实现将数据插入当前模型。此功能的默认实现不会覆盖模型中的任何数据；相反，它尝试将数据项作为项的同级或子项插入。 要利用QabstractemModel对内置MIME类型的默认实现，新模型必须提供以下函数的重新实现： insertRows（） 这些函数使模型能够使用qabstractemmodel：：dropMimeData（）提供的现有实现自动插入新数据。 insertColumns（） setData 允许用项目填充新行和新列。 setItemData 此函数为填充新项提供更有效的支持。 要接受其他形式的数据，必须重新实现以下功能： supportDropActions 用于返回拖放操作的组合，指示模型接受的拖放操作类型。 mimeTypes 用于返回可由模型解码和处理的MIME类型列表。通常，支持输入到模型中的MIME类型与它在编码数据以供外部组件使用时可以使用的类型相同。 dropMimeData 对通过拖放操作传输的数据执行实际解码，确定在模型中设置数据的位置，并在必要时插入新行和新列。如何在子类中实现此功能取决于每个模型公开的数据的要求。 如果dropMimeData（）函数的实现通过插入或删除行或列来更改模型的维度，或者如果修改了数据项，则必须小心确保发出了所有的相关信号。这时候调用子类中其他函数的重新实现，如setData（）、insertRows（）和insertColumns（），就可以确保模型的行为一致。 为了确保拖动操作正常工作，必须重新实现以下从模型中删除数据的功能： removeRows（） removeRow（） removeColumns（） removeColumns（） 有关在项目视图中拖放的详细信息，请参阅在项目视图中使用拖放。 便利性视图方便视图（QListWidget、QTableWidget和QTreeWidget）覆盖了默认的拖放功能，以提供不太灵活但更自然的行为，适用于许多应用程序。例如，由于更常见的做法是将数据放入QTableWidget中的单元格，用传输的数据替换现有内容，因此模型将设置目标项的数据，而不是在模型中插入新行和列。有关在便利视图中拖放的详细信息，请参见在项目视图中使用拖放。 针对大量数据的性能优化canFetchMore（）函数检查父级是否有更多可用数据，并相应地返回true或false。函数的作用是：根据指定的父级获取数据。例如，可以在涉及增量数据的数据库查询中组合这两个功能，以填充QabstractemModel。我们重新实现canFetchMore（）以指示是否有更多数据需要提取，并根据需要使用fetchMore（）填充模型。 另一个例子是动态填充的树模型，当树模型中的一个分支展开时，我们将重新实现fetchMore（）。 如果重新实现fetchMore（）将行添加到模型中，则需要调用beginInsertRows（）和endInsertRows（）。此外，必须重新实现canFetchMore（）和fetchMore（），因为它们的默认实现返回false，并且不执行任何操作。","categories":[{"name":"Qt技术文档","slug":"Qt技术文档","permalink":"http://example.com/categories/Qt%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]}],"categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"现代C++","slug":"现代C","permalink":"http://example.com/categories/%E7%8E%B0%E4%BB%A3C/"},{"name":"Qt技术文档","slug":"Qt技术文档","permalink":"http://example.com/categories/Qt%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"},{"name":"计算机网络笔记","slug":"计算机网络笔记","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"Network","slug":"Network","permalink":"http://example.com/tags/Network/"}]}