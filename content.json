{"meta":{"title":"Cozard 技术空间","subtitle":"规划、设计、探索","description":"Cozard 的官方博客","author":"ZYZ","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-09-19T05:03:38.000Z","updated":"2022-09-19T05:04:00.628Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-18T15:41:37.000Z","updated":"2022-09-18T15:42:24.344Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-09-18T15:40:42.000Z","updated":"2022-09-18T15:43:05.594Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Y-组合子","slug":"C++函数式编程-9-Y-组合子","date":"2022-09-19T04:48:53.000Z","updated":"2022-09-19T05:22:08.140Z","comments":true,"path":"2022/09/19/C++函数式编程-9-Y-组合子/","link":"","permalink":"http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-9-Y-%E7%BB%84%E5%90%88%E5%AD%90/","excerpt":"Y-组合子（Y-Combinator）只是一个听起来很厉害，也很难的概念，然而实践上没有什么太大价值，因为它性能较低。不过学习它能让我们更好地理解函数式编程。 Y-combinator由Haskell Brooks Curry提出，Haskell的那个Haskell，Curry的那个Curry。","text":"Y-组合子（Y-Combinator）只是一个听起来很厉害，也很难的概念，然而实践上没有什么太大价值，因为它性能较低。不过学习它能让我们更好地理解函数式编程。 Y-combinator由Haskell Brooks Curry提出，Haskell的那个Haskell，Curry的那个Curry。 不动点（fixed-point）想像一个函数G，它接收一个函数F作为参数，返回另一个函数。 如果满足F = G（F）则称F为G的不动点 如果F是G的不动点，那么：F = G（F）=G（G（F））=G（G（G（F）））= …… 匿名递归想象一个匿名函数（为了方便称呼，给它名字M），它接收一个函数f，然后在其函数体内调用f。 在此基础上，如果这样定义一个函数：Func = M（Func）； 这样Func将成为递归函数，因为： 12345Func（）//相当于M（Func）（）//M在函数体内调用Func，于是相当于Func（） 无限递归。 然而如果在M的函数体内加上递归终止条件与迭代条件，Func就能成为一个真正的递归函数。 1234567//伪代码auto M = [](接收int a返回int b的函数)&#123; return a == 0 ? 1 : 函数(a - 1);&#125;Func&lt;int(int)&gt; = M(Func);//Func是阶乘递归 成功用M构造了递归。注意看M的表达式，当M返回函数的时候： Func = M（Func）； Func成为了M的不动点，同时Func自己是递归函数。 显然，如果需要写一个匿名递归函数，M部分是能很快写出来的，因为M知道递归函数的名字Func，M可以在自己的函数体里面写Func的递归逻辑，就像在Func的函数体里一样。 难点在已知M的情况下找出Func，是否能找到这样一个具有普遍性的函数，它接收M，返回Func？ 数学推导格式规定规则一： 规则二： 举例：化简式子 可以看到，左边括号里是一个函数，用7来调用它，得 可以看到，左边括号里是一个函数，用2来调用它，得 很好，现在你已经掌握这套推导规则了，现在让我们引入Y-组合子吧！ Y-组合子Haskell Curry找到了一个函数 Y-组合子，它的形式是这样的： 它有这样的性质：（F是函数） 即Y（F）是 F 的不动点 下面开始数学证明： //注意了要把当成一个整体来调用函数了 证毕。 利用Y-组合子实现匿名递归比照前面的几个式子： 其中Func是递归函数。 不妨令 Y（F）= Func ，M = F，上述公式完全成立 代换，得： 成功了。 C++实现Y-组合子代码如下 1234567891011auto Y = [](auto&amp;&amp; f)&#123; return [&amp;f](auto&amp;&amp; x)&#123; return f([&amp;x](auto&amp;&amp; y)&#123; return x(x)(y); &#125;); &#125;[&amp;f](auto&amp;&amp; x)&#123; return f([&amp;x](auto&amp;&amp; y)&#123; return x(x)(y); &#125;); &#125;;&#125;; 来使用一下 1234567auto M = [](auto&amp;&amp; f)&#123; return [](int n)&#123; n == 0 ? 1 : f(n); &#125;;&#125;;auto factorial = compose(Y, M); 这样就完成了匿名递归函数的编写。 对了还有个可优化的点，还记得我们之前说过的柯里化吗，既然Y组合子每次使用时都要和M函数结合，为什么我们不把Y组合子直接固定在compose里呢？ 123auto rec = curry(compose)(Y);auto factorial = rec(M); 简洁，优雅，这便是函数式编程的魅力。 这时候你可能已筋疲力竭，不禁会想，弄这个开销巨大，对于递归编写又没多少简化的东西干什么呢？我想说的是，编程不仅仅是枯燥乏味的增删改查—— 一轮精妙的推导，一节优美的实现，一段如诗的代码，才是程序员的浪漫与追求。","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"操作容器","slug":"C++函数式编程-8-操作容器","date":"2022-09-19T04:47:55.000Z","updated":"2022-09-19T05:22:15.044Z","comments":true,"path":"2022/09/19/C++函数式编程-8-操作容器/","link":"","permalink":"http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-8-%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8/","excerpt":"在函数式编程中，变量是不可变的，当产生一个新值时，我们创造一个新变量来“代表”它，而不是“修改”现有的变量。 对于容器也是一样，对容器的操作不会改变现有容器里的值以及容器本身，而是产生一个新的容器，里面装着新的值。","text":"在函数式编程中，变量是不可变的，当产生一个新值时，我们创造一个新变量来“代表”它，而不是“修改”现有的变量。 对于容器也是一样，对容器的操作不会改变现有容器里的值以及容器本身，而是产生一个新的容器，里面装着新的值。 可以使用C++标准库自带的**std::vector(C++11)**作为容器，也可以自己写一个。 这里把vector重新命个名，叫seq。 12template&lt;typename T = int&gt;using seq = std::vector&lt;T&gt;; 操作容器与命令式编程不同，函数式编程操作容器往往不是靠下标，而是用一组可复用的函数和功能函数进行组合来整体操作容器。 有点绕口，来直接看实例。 map将容器中的每个值用传入的函数映射成新的值，然后装入新的容器中，看例子。 123456789std::vector&lt;int&gt; vec&#123;1, 2, 3, 4, 5&#125;;auto increase = [](int a)&#123; return a + 1;&#125;;auto new_vec = map(vec, increase);//new_vec : &#123;2, 3, 4, 5, 6&#125; 下面是针对std::vector的map的一种实现（C++11），你也可以实现自己的版本 12345678template&lt;typename T, typename F&gt;constexpr auto map(seq&lt;T&gt; vec, F&amp;&amp; f) &#123; seq new_vec = vec; for (unsigned i = 0; i &lt; my_array.size(); i++) &#123; new_vec[i] = std::forward&lt;F&gt;(f)(new_vec[i]); &#125; return new_vec;&#125; filter将容器中满足某个条件的值复制到新的容器中，看例子。 123456789std::array&lt;int&gt; my_array&#123;1, 2, 3, 4, 5&#125;;auto judge = [](int a)&#123; return a &gt; 3;&#125;;auto new_array = filter(my_array, judge);//new_array : &#123;4, 5&#125; 下面是针对std::vector的filter的一种实现（C++11），你也可以实现自己的版本 12345678910template&lt;typename T, typename F&gt;constexpr auto filter(std::seq&lt;T&gt; vec, F&amp;&amp; f) &#123; std::seq&lt;T&gt; n_vec; for (auto value : vec) &#123; if (f(value)) &#123; n_vec.push_back(std::move(value)); &#125; &#125; return n_vec;&#125; reduce这个用图片更易理解 reduce接收三个参数，第一个是列表，第二个是接收两个参数的函数，第三个是初始值，返回一个值。 来实现reduce 123456789101112template&lt;typename T, typename F, typename Init&gt;constexpr auto reduce(seq&lt;T&gt; vec, F&amp;&amp; f, Init&amp;&amp; init) &#123; std::decay_t&lt;Init&gt; v; v = init; constexpr if (vec.size() == 0) &#123; return v &#125; for (auto&amp; value : vec ) &#123; v = f(v, value); &#125; return v;&#125;","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"函子","slug":"C++函数式编程-7-函子","date":"2022-09-19T04:46:34.000Z","updated":"2022-09-19T05:22:25.888Z","comments":true,"path":"2022/09/19/C++函数式编程-7-函子/","link":"","permalink":"http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-7-%E5%87%BD%E5%AD%90/","excerpt":"从本节开始，我们就要接触“容器”了。在大多数情况下，函数式编程是操作放在“容器”中的数据而不是操作裸数据。让我们从最简单的容器——functor开始吧。 Functor（函子）定义： 函子必须是一个容器 函子必须有map方法，（map：接收一个函数，map用functor里的值调用这个函数，然后根据返回值构造一个新的函子。）","text":"从本节开始，我们就要接触“容器”了。在大多数情况下，函数式编程是操作放在“容器”中的数据而不是操作裸数据。让我们从最简单的容器——functor开始吧。 Functor（函子）定义： 函子必须是一个容器 函子必须有map方法，（map：接收一个函数，map用functor里的值调用这个函数，然后根据返回值构造一个新的函子。） 来实现一个最简单的函子吧 1234567891011121314151617#include&lt;functional&gt;template&lt;typename T&gt;class functor_t &#123; T t;public: functor_t(T v) &#123; t = v; &#125; auto map(std::function&lt;T(T)&gt;&amp;&amp; mapping) &#123; return functor_t&lt;T&gt;(std::forward&lt;std::function&lt;T(T)&gt;&gt;(mapping)(t)); &#125;&#125;;template&lt;typename T&gt;constexpr functor_t&lt;std::decay_t&lt;T&gt;&gt; functor_of(T&amp;&amp; t) &#123; return &#123; std::forward&lt;T&gt;(t) &#125;;&#125;//约定俗成，functor应该有一个叫做of的方法来构建一个functor 函数式编程里的计算大多是操作函子而不是操作函子里的值。 123456789auto functorA = functor(2);auto add_3 = curry(add)(3);auto multiply_5 = curry(multiply)(5);auto mod_2 = curry(mod)(2);auto print = [](auto&amp;&amp; a)&#123;std::cout&lt;&lt;a;return a;&#125;auto processed = functorA.map(add_3).map(multiply_5).map(mod_2).map(is_even).map(print); 函子还可以连续调用，来看下面例子。 123456auto num = functor_of(1);auto num_is_even = num.map(is_even);//num_is_even同样是一个functornum.map 在函子的基础上添加某些特性可以构造特殊的函子。 Maybemaybe是特殊的函子，它具有函子的所有特征，此外，它实现了“空值过滤”的功能。 它的map具有一种特点，如果maybe里的值是一个“空值”，那么map就会直接将maybe拷贝一份作为返回值，而不会尝试拿“空值”来调用传入的函数（如果调用了，可能会产生错误）。 来实现一下吧。 Applicativeapplicative是特殊的函子，它具有函子的所有特征，此外，它实现了“apply”的功能。 如果一个applicative里装着值，另一个applicative里装着接收这个值的函数，装着值的applicative就可以apply另一个applicative，利用函数的返回值创建一个新的applicative。 Monad（单子）monad是特殊的函子，它具有函子的所有特征，此外，它实现了“flatmap”的功能。 有时处理函子时会出现“函子嵌套”，就是说函子内部储存的值也是一个函子。而monad的flatmap保证函子内部储存的值一定不是函子。（flatmap好比将嵌套的函子“拍平”） 来实现一下 更美观的书写方式C++20的range库使用了类似Unix的“管道运算符”，可以让函子（以及一些容器）的函数调用变得极其优美。首先，我们需要重载functor的 | 运算符。 1234567891011121314151617181920#include&lt;functional&gt;template&lt;typename T&gt;class functor_t &#123; T t;public: functor_t(T v) &#123; t = v; &#125; auto map(std::function&lt;T(T)&gt;&amp;&amp; mapping) &#123; return functor_t&lt;T&gt;(std::forward&lt;std::function&lt;T(T)&gt;&gt;(mapping)(t)); &#125; auto operator|(std::function&lt;T(T)&gt;&amp;&amp; mapping) &#123; return functor_t&lt;T&gt;(std::forward&lt;std::function&lt;T(T)&gt;&gt;(mapping)(t)); &#125; &#125;;template&lt;typename T&gt;constexpr functor_t&lt;std::decay_t&lt;T&gt;&gt; functor_of(T&amp;&amp; t) &#123; return &#123; std::forward&lt;T&gt;(t) &#125;;&#125; 本质是map改了个名字，但是调用效果非常棒。 改写本章开头functor演示的代码。 12345678auto processed = functorA |add_3 |multiply_5 |mod_2 |is_even |print ; 好看吧，这种写法清晰明朗，比一长条的map要易读。而且这种写法也符合无参风格（point-free），是函数式编程所提倡的！ 接下来一章，我们将学习C++的range库，深入了解一下C++特色的函数式编程。","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"小结一下","slug":"C++函数式编程-6-小结一下","date":"2022-09-19T04:45:51.000Z","updated":"2022-09-19T05:23:04.023Z","comments":true,"path":"2022/09/19/C++函数式编程-6-小结一下/","link":"","permalink":"http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-6-%E5%B0%8F%E7%BB%93%E4%B8%80%E4%B8%8B/","excerpt":"在前面的章节中，我们已经初步学习了函数式编程的基本思维以及概念，下面来梳理一下： 函数式编程将函数作为一等公民 函数式编程是声明式的 函数式编程要求不要改变变量的值","text":"在前面的章节中，我们已经初步学习了函数式编程的基本思维以及概念，下面来梳理一下： 函数式编程将函数作为一等公民 函数式编程是声明式的 函数式编程要求不要改变变量的值 尽量编写纯函数 使用组合函数将纯函数组合起来 使用std::function实现lambda的递归 使用组合函数时可以无视被组合函数的中间参数，这种风格叫做Point-Free 使用偏函数与柯里化减少函数的参数，最好降低至一个 在接下来的章节中，我们将要接触到“容器”以及对容器的操作。很多时候我们并不处理裸露在外面的值，而是处理被包裹在容器中的值。 我们还将接触到一些有趣的数学推导，见证Y-组合子是如何帮助我们实现匿名递归的。 C++20对于Range的支持与管道运算符 对容器的操作 函子Functor以及衍生 Y-组合子与递归 我准备了一些题目，尝试着用函数式编程的思维解决他们。这些题目有助于加深你对函数式编程的理解。","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"偏函数和柯里化","slug":"C++函数式编程-5-偏函数和柯里化","date":"2022-09-19T04:44:17.000Z","updated":"2022-09-19T05:23:13.265Z","comments":true,"path":"2022/09/19/C++函数式编程-5-偏函数和柯里化/","link":"","permalink":"http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-5-%E5%81%8F%E5%87%BD%E6%95%B0%E5%92%8C%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"函数式编程特别重视一元函数 Partial（偏函数）“偏函数”指：固定某个参数为特定值，然后返回一个接收余下参数的函数。这是一种减少参数的方式。 打个比方：我们已经有了greater函数，它接收两个参数a和b。","text":"函数式编程特别重视一元函数 Partial（偏函数）“偏函数”指：固定某个参数为特定值，然后返回一个接收余下参数的函数。这是一种减少参数的方式。 打个比方：我们已经有了greater函数，它接收两个参数a和b。 如果我想编写一个greater_than_6函数，就可以基于已有的greater函数，将参数b固定为6，这样，得到的新函数greater_than_6只接收一个参数。 来写一下partial 12345template&lt;class _Fx, class... Args&gt;constexpr auto partial(_Fx&amp;&amp; f, Args&amp;&amp;... args)&#123; return std::bind_front(f, std::forward&lt;Args&gt;(args)...);&#125; 写完了，C++20及以上适用。 也可以用C++标准库（C++11）提供的std::bind来固定参数： 1234567#include&lt;functional&gt;using namespace std::placeholders;auto more_than_6 = std::bind(more, _1, 6);more_than_6(1); //false 以下是bind用法的归纳： 123456789101112131415161718192021222324252627282930313233#include&lt;functional&gt;using namespace std::placeholders;//占位符被定义在这个名字空间里//std::bind接收 n+1 个参数，其中n是函数参数的个数//std::bind的第一个参数是函数名，后面的参数要么是具体的值，要么是占位符//占位符类似这种：_1, _2, _3,......//占位符表示 “生成的新函数的第n个参数” 将会被放在原函数的占位符位置。来看演示auto less_than_6 = std::bind(more, 6, _1);//看，一共只有一个占位符，这意味着新函数一共只会有一个参数//调用这个新函数时，这个参数会被放进对应占位符的位置less_than_6(10);//bind的顺序是(6, _1), 10被放进_1//所以相当于调用：more(6, 10);//来来来我们再比较一下std::bind(more, 6, _1); less_than_6(10); more(6, 10);//我想你已经大概明白了，来看看复杂的auto less = std::bind(more, _2, _1);//这次有两个占位符less(6, 10);//6被放进占位符_1 ,因为它是新函数的第一个参数//10被放进占位符_2 ,因为它是新函数的第二个参数//bind的顺序是(_2, _1)//所以等效于调用：more(10, 6); Curry（柯里化）柯里化是特殊的Partial（偏函数）。 它并不固定任何一个参数，被柯里化的函数有这样的行为： 只接收一个或多个参数并固定它，返回一个被柯里化的接收剩余参数的函数 当所有参数都被固定时返回结果 概念有点绕，来看演示： 12345678910111213141516//函数名curryauto sum_of_three = [](auto a, auto b, auto c)&#123; return a + b + c;&#125;auto curried = curry(sum_of_three);//以下的调用法等效sum_of_three(1, 2, 3); //6curried_sum_of_three(1)(2)(3); //6//理解柯里化函数的调用法auto curried_sum_1 = curried(1);auto curried_sum_2 = curried_sum_1(2);auto curried_sum_3 = curried_sum_2(3); //6 标准库中没有这样的函数，我们来自己写一个： （利用C++20的concept弄的，早些版本的写法不熟练） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778template&lt;class F&gt;struct curry_t &#123; F f; template&lt;class... Args&gt; requires (std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)&amp; noexcept(noexcept(std::invoke(f, std::forward&lt;Args&gt;(args)...))) -&gt;decltype(std::invoke(f, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; requires (!std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)&amp; noexcept(noexcept(curry(partial(f, std::forward&lt;Args&gt;(args)...)))) -&gt;decltype(curry(partial(f, std::forward&lt;Args&gt;(args)...))) &#123; return curry(partial(f, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; requires (std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)&amp;&amp; noexcept(noexcept(std::invoke(f, std::forward&lt;Args&gt;(args)...))) -&gt;decltype(std::invoke(f, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; requires (!std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)&amp;&amp; noexcept(noexcept(curry(partial(f, std::forward&lt;Args&gt;(args)...)))) -&gt;decltype(curry(partial(f, std::forward&lt;Args&gt;(args)...))) &#123; return curry(partial(f, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; requires (std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)const &amp; noexcept(noexcept(std::invoke(f, std::forward&lt;Args&gt;(args)...))) -&gt;decltype(std::invoke(f, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; requires (!std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)const &amp; noexcept(noexcept(curry(partial(f, std::forward&lt;Args&gt;(args)...)))) -&gt;decltype(curry(partial(f, std::forward&lt;Args&gt;(args)...))) &#123; return curry(partial(f, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; requires (std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)const &amp;&amp; noexcept(noexcept(std::invoke(f, std::forward&lt;Args&gt;(args)...))) -&gt;decltype(std::invoke(f, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; requires (!std::is_invocable&lt;F, Args...&gt;::value) constexpr auto operator()(Args&amp;&amp;... args)const &amp;&amp; noexcept(noexcept(curry(partial(f, std::forward&lt;Args&gt;(args)...)))) -&gt;decltype(curry(partial(f, std::forward&lt;Args&gt;(args)...))) &#123; return curry(partial(f, std::forward&lt;Args&gt;(args)...)); &#125;&#125;;export template&lt;class F&gt;constexpr curry_t&lt;std::decay_t&lt;F&gt;&gt; curry(F&amp;&amp; f)&#123; return &#123; std::forward&lt;F&gt;(f) &#125;;&#125; 另外说一下，纯粹的curry严格地让函数一次只接收一个参数，而上面的curry要求更宽松，你可以一次传几个参数进去。","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"胶水","slug":"C++函数式编程-4-胶水","date":"2022-09-19T04:39:56.000Z","updated":"2022-09-19T05:23:26.818Z","comments":true,"path":"2022/09/19/C++函数式编程-4-胶水/","link":"","permalink":"http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-4-%E8%83%B6%E6%B0%B4/","excerpt":"已经编写了一些小型函数，我们来看看它们可以如何变化与组合 记住法则一：函数是一等公民。","text":"已经编写了一些小型函数，我们来看看它们可以如何变化与组合 记住法则一：函数是一等公民。 函数否定 希望编写一个函数，它接收另一个函数，返回这个函数的否定函数。 C++17标准库提供了这个函数：std::not_fn （接收一个返回bool类型的函数，返回一个反转原函数返回值的新函数） 来试一下： 1234567auto is_odd = [](auto a)&#123; return a % 2;&#125;;auto is_even = std::not_fn(is_odd);//判断奇偶的函数//其中判断偶的函数没有直接编写，而是从判断奇的函数中直接生成 把函数当作参数，“函数式编程”是不是有点意思了？再来看这个： 12345auto not_equ = std::not_fn(eq);//从 “等于” 函数中直接生成 “不等于” 函数not_equ(1, 2); //trueeq(1, 2); //false 函数或，函数与有了逻辑非，怎能没有逻辑或和逻辑与呢？但很遗憾，标准库没有提供。 怕什么，学C++的最会造轮子了！来写一下试试。 （注：若看不懂，建议复制粘贴直接用，这部分的语法我将在“模板元编程”部分讲解。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//函数逻辑或#include&lt;functional&gt;template&lt;class F1, class F2&gt;struct or_fn_t &#123; F1 f1; F2 f2; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args)const &amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp;&amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const &amp;&amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) || std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125;&#125;;template&lt;class F1, class F2&gt;constexpr or_fn_t&lt;std::decay_t&lt;F1&gt;, std::decay_t&lt;F2&gt;&gt; or_fn(F1&amp;&amp; f1, F2&amp;&amp; f2)&#123; return &#123; std::forward&lt;F1&gt;(f1), std::forward&lt;F2&gt;(f2) &#125;;&#125;//函数逻辑与template&lt;class F1, class F2&gt;struct and_fn_t &#123; F1 f1; F2 f2; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args)const&amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp;&amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const&amp;&amp; noexcept(noexcept(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...))) -&gt; decltype(std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...)) &#123; return std::invoke(f1, std::forward&lt;Args&gt;(args)...) &amp;&amp; std::invoke(f2, std::forward&lt;Args&gt;(args)...); &#125;&#125;;template&lt;class F1, class F2&gt;constexpr and_fn_t&lt;std::decay_t&lt;F1&gt;, std::decay_t&lt;F2&gt;&gt; and_fn(F1&amp;&amp; f1, F2&amp;&amp; f2)&#123; return &#123; std::forward&lt;F1&gt;(f1), std::forward&lt;F2&gt;(f2) &#125;;&#125; 现在有两个函数 or_fn 和 and_fn。 (接收两个参数完全相同且返回bool类型的函数，返回经过逻辑组合的新函数） 来用一下试试： 1234567891011auto eq_less = or_fn(eq, less);//“小于”和“等于”通过 逻辑或 生成“小于等于”auto greater = not_fn(eq_less);//否定 “小于等于” 来生成 “大于”auto eq_greater = or_fn(eq, greater);//简单粗暴的 “或” 组合eq_greater(1, 2); //falsegreater(2, 1); //true 现在，你体会到函数式编程所说的“函数是一等公民”了吗？ 凭借类似于“胶水”的组合函数，我们能像变量一样操纵、组合与生成新函数。 函数组合数学中有“复合函数”这一概念。复合函数将前一个函数的输出用作下一个函数的输入，来看几张图： （图引用自https://zhuanlan.zhihu.com/p/74777206） 命令式编程存在一系列中间变量 函数式编程 函数组合 在函数式编程中我们称此为“函数组合”（compose），函数组合是生成新函数的重要途径。 C++标准库没有“函数组合”函数，所以又到了喜闻乐见的造轮子时间~ （注：若看不懂，建议复制粘贴直接用，这部分的语法我将在“模板元编程”部分讲解。） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//函数组合，从右往左执行template&lt;class F1, class F2&gt;struct compose_t &#123; F1 f1; F2 f2; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp; noexcept(noexcept(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const &amp; noexcept(noexcept(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp;&amp; noexcept(noexcept(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const &amp;&amp; noexcept(noexcept(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f1, std::invoke(f2, std::forward&lt;Args&gt;(args)...)); &#125;&#125;;template&lt;class F1, class F2&gt;constexpr compose_t&lt;std::decay_t&lt;F1&gt;, std::decay_t&lt;F2&gt;&gt; compose(F1&amp;&amp; f1, F2&amp;&amp; f2)&#123; return &#123; std::forward&lt;F1&gt;(f1), std::forward&lt;F2&gt;(f2) &#125;;&#125;template&lt;class F1, class F2, class... Args&gt;constexpr compose_t&lt;std::decay_t&lt;F1&gt;, std::decay_t&lt;compose_t&lt;F2, Args...&gt;&gt;&gt; compose(F1&amp;&amp; f1, F2&amp;&amp; f2, Args&amp;&amp;... args)&#123; return &#123; std::forward&lt;F1&gt;(f1), std::forward&lt;compose_t&lt;F2, Args...&gt;&gt;(compose(f2, args)) &#125;;&#125;//函数组合，从左往右执行template&lt;class F1, class F2&gt;struct pipe_t &#123; F1 f1; F2 f2; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp; noexcept(noexcept(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const&amp; noexcept(noexcept(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp;&amp; noexcept(noexcept(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)); &#125; template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const&amp;&amp; noexcept(noexcept(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)))) -&gt; decltype(std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...))) &#123; return std::invoke(f2, std::invoke(f1, std::forward&lt;Args&gt;(args)...)); &#125;&#125;;template&lt;class F1, class F2&gt;constexpr pipe_t&lt;std::decay_t&lt;F1&gt;, std::decay_t&lt;F2&gt;&gt; pipe(F1&amp;&amp; f1, F2&amp;&amp; f2)&#123; return &#123; std::forward&lt;F1&gt;(f1), std::forward&lt;F2&gt;(f2) &#125;;&#125;template&lt;class... Args, class F1, class F2&gt;constexpr pipe_t&lt;std::decay_t&lt;pipe_t&lt;Args..., F1&gt;&gt;,std::decay_t&lt;F2&gt;&gt; pipe(Args&amp;&amp;... args, F1&amp;&amp; f1, F2&amp;&amp; f2)&#123; return &#123; std::forward&lt;pipe_t&lt;Args..., F1&gt;&gt;(pipe(f2, args)) ,std::forward&lt;F2&gt;(f2) &#125;;&#125; 现在有了两个函数compose和pipe 演示一下用法： 12345678910111213141516//compose和pipe接收任意个数的函数，返回经过组合的函数//其中compose是从右向左组合，pipe是从左向右组合auto sum_is_odd = compose(is_odd, sum);sum_is_odd(1, 3);//相当于调用is_odd(sum(1, 3));//结果是falseauto mul_is_odd = pipe(mul, is_odd);mul_is_odd(1, 3);//相当于调用is_odd(mul(1, 3));//结果是true 有了compose和pipe，我们能将一系列过程看作一个整体，从而忽略复杂的中间量，简化代码。 此外，注意到如果函数只接收一个参数，我们就有机会连续组合多个函数 12345678auto add_1 = [](int a)&#123; return a + 1;&#125;;auto add_4 = compose(add_1, add_1, add_1, add_1);//只是举个例子，不必纠结实用性add_4(1); //5 我们目前编写的大多数函数是多参数函数，在下一节我们来看看如何将多参数函数转化为单参数函数。","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"积木","slug":"C++函数式编程-3-积木","date":"2022-09-19T04:38:07.000Z","updated":"2022-09-19T05:23:43.740Z","comments":true,"path":"2022/09/19/C++函数式编程-3-积木/","link":"","permalink":"http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-3-%E7%A7%AF%E6%9C%A8/","excerpt":"下面我们来趁热打铁，编写一些简单的纯函数来练练手，逐渐熟悉函数式编程的思维方式。 打开你的编辑器，和我一起写 这些纯函数将会在之后的学习中用到","text":"下面我们来趁热打铁，编写一些简单的纯函数来练练手，逐渐熟悉函数式编程的思维方式。 打开你的编辑器，和我一起写 这些纯函数将会在之后的学习中用到 包装个简单的算数操作试试12345678910111213141516171819auto sum = [](auto a, auto b)&#123; return a + b;&#125;;auto sub = [](auto a, auto b)&#123; return a - b;&#125;;auto mul = [](auto a, auto b)&#123; return a * b;&#125;;auto divi = [](auto a, auto b)&#123; return a / b;&#125;;auto mod = [](auto a, auto b)&#123; return a % b;&#125;; 看上去没什么用，然而这种高度抽象的简单函数正是复杂函数的基础。 接下来编写逻辑函数与比较函数1234567891011121314151617181920212223auto not_ = [](bool a)&#123; return !a;&#125;;auto and_ = [](bool a, bool b)&#123; return a &amp;&amp; b;&#125;;auto or_ = [](bool a, bool b)&#123; return a || b;&#125;;auto xor_ = [](bool a, bool b)&#123; return (!a&amp;&amp;b)||(!b&amp;&amp;a);&#125;;auto less = [](auto a, auto b) &#123; return a &lt; b;&#125;;auto eq = [](auto a, auto b) &#123; return a == b;&#125;; 函数式编程有点像搭积木，我们先造好一些小型积木，到后面再看看它们能组合出什么好玩的大家伙来。","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"开启新世界的大门","slug":"C++函数式编程-2-开启新世界的大门","date":"2022-09-18T16:11:00.000Z","updated":"2022-09-19T05:23:49.069Z","comments":true,"path":"2022/09/19/C++函数式编程-2-开启新世界的大门/","link":"","permalink":"http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-2-%E5%BC%80%E5%90%AF%E6%96%B0%E4%B8%96%E7%95%8C%E7%9A%84%E5%A4%A7%E9%97%A8/","excerpt":"函数式编程无论是面向过程还是面向对象，都是一种“指令式编程”模式：程序员“告诉”机器怎么做事，把事情的解决方案一步步列出来。 与“指令式编程”对应的是“声明式编程”：程序员把重心放在“做什么”而不是“怎么做”。打个比方：使用数据库语言SQL时，用户是不必操心机器是怎么插入或者查找数据的，只需要一句声明“我要做什么”，机器便会自动寻找解决方案；此外，一些逻辑编程语言，也是“声明式”的。 函数式编程偏向于“声明式编程”而不是“指令式编程”。","text":"函数式编程无论是面向过程还是面向对象，都是一种“指令式编程”模式：程序员“告诉”机器怎么做事，把事情的解决方案一步步列出来。 与“指令式编程”对应的是“声明式编程”：程序员把重心放在“做什么”而不是“怎么做”。打个比方：使用数据库语言SQL时，用户是不必操心机器是怎么插入或者查找数据的，只需要一句声明“我要做什么”，机器便会自动寻找解决方案；此外，一些逻辑编程语言，也是“声明式”的。 函数式编程偏向于“声明式编程”而不是“指令式编程”。 万事开头难，学习函数式编程将是一段难忘的旅途，途中可能会有各种挫折，但请不要放弃，毕竟你连C++的基本语法都啃下来了，还有什么东西是学不会的呢？ 函数式编程的优点1. 可读性强函数式编程的“声明式”特征意味着程序员将更多关注某个代码片段的“作用”而不是“实现细节”，其代码相较于其他编程范式具有较强的可读性。 需要注意的一点是，对于刚入门函数式编程的新手，函数式编程的一些概念很陌生难懂。出现这种情况的原因并不是因为函数式编程本身“难于阅读”，而仅仅是因为“不熟悉”。打个比方，C语言初学者对数组下标以0开始的迷惑，难道也是。 因此，想要体会到函数式编程的“强可读性”，前提就是要多多练习，熟悉函数式编程风格与思路。 2. 高强度复用函数式编程代码抽象程度很高，粒度比较低，复用非常方便。 很多时候并不直接编写很大的函数，而是将小函数拼接组合，像用胶水粘合积木一样。显然，胶水能复用，部分积木也能复用。 实际编程中常用compose组合函数，curry柯里函数，not_fn取反函数。它们是高度抽象可复用函数的典范。 3. 适合高并发现代微处理器晶体管数目增长放缓，而核心数增长加快，这意味着可并发的程序越来越有性能优势。 一般的指令式程序需要耗费一部分时间资源在线程/进程交互上面。而函数式编程因为没有中间状态，变量不可更改等特征，可以轻易支持高并发。 使用C++进行函数式编程Haskell、Scala、JavaScript 等语言以函数式编程闻名，C++作为现代语言特性的“究极缝合怪”也紧紧跟上了时代的脚步。自C++11开始，C++陆续添加了不少好用的新特性用以支持函数式编程： auto类型推导 lambda表达式 std::function函数包装器 std::bind工具 等等还有很多，我会在需要时一一阐述。 原教旨主义（原教旨主义：最严格的函数式编程要求） 鉴于你现在对函数式编程的印象可能是很抽象的，下面我向你灌输几个概念，以使你迅速适应函数式编程的思维方式。 。 。 。 准备好哦~ 。 。 。 开始！ 法则零：函数是 数据的“映射”而不是“操作”的集合在面向过程编程语言里，函数（function）是一组代码（或者说操作）的集合，现在，请你忘掉它们，回想起在数学中函数是如何定义的。 函数为两集合间的一种对应关系：输入值集合中的每项元素皆能对应唯一一项输出值集合中的元素。 “函数式编程”中的函数是数学意义上的函数。“函数”应该具有以下特点： 引用透明：函数的输出只依赖输入的值，与外界其他量没有任何关系。 无副作用：函数调用不会产生除运算之外其他效果，同一组数据永远得到相同的值。 我们称拥有这些特点的函数为 纯函数 。 法则一：函数是一等公民函数可以和变量一样，可以赋值给其他变量，也可以作为参数，传入一个函数，或者作为别的函数的返回值。 法则二：变量不可修改函数式编程认为“状态量”是导致程序复杂难以分析的根源。程序在不同运行时刻具有不同的“状态”（比如说循环语句的计数变量、累加过程中的计数变量等等），这些状态量时常变化，使程序的复杂度大大增加。 因此，在函数式编程中，你应尽量不要修改变量，这意味着： 不要使用循环语句（应该使用递归）。 函数应当返回一个新变量而不是在原有变量上做修改（函数即是映射）。 法则三：使用表达式而不是语句：表达式是一段单纯的运算过程，总是有返回值，而语句是执行某种操作，没有返回值。 函数式编程中的每一步都是单纯的运算，而且都有返回值。 完毕。 以上勾勒了函数式编程的轮廓，不理解也没关系，继续下面的章节，在实践中慢慢体会函数式编程的魅力。","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"lambda 表达式","slug":"C++函数式编程-1-lambda 表达式","date":"2022-09-18T16:10:57.000Z","updated":"2022-09-19T05:23:51.998Z","comments":true,"path":"2022/09/19/C++函数式编程-1-lambda 表达式/","link":"","permalink":"http://example.com/2022/09/19/C++%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-1-lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"熟悉一下C++函数式编程的主角：lambda表达式。 请将你的编译器版本调到C++17及以上。 定义一个labmda变量（C++11与C++14）labmda既是一个函数，也是一个变量（事实上，它是一个由编译器自动生成的可调用类），让我们先来看看labmda是什么样子的：","text":"熟悉一下C++函数式编程的主角：lambda表达式。 请将你的编译器版本调到C++17及以上。 定义一个labmda变量（C++11与C++14）labmda既是一个函数，也是一个变量（事实上，它是一个由编译器自动生成的可调用类），让我们先来看看labmda是什么样子的： 1234567891011121314151617181920212223242526272829303132333435[]()&#123;&#125;//此即为labmda的基本结构//记住labmda既是一个函数，也是一个变量auto func1 = []()&#123;&#125;;//一般使用自动类型推导来定义labmda变量，因为通常labmda表达式的类型名很长//现在我们拥有了一个叫func1的labmda表达式变量auto func2 = [](int a)&#123;&#125;//我们的func2现在可以接受一个int类型的变量作为参数//但是它什么都不做auto func3 = [](int a)&#123; std::cout&lt;&lt;a; return;&#125;//func3拥有了函数体，它打印传入的int类型的变量//记住labmda既是一个函数，也是一个变量auto func4 = [](int a)&#123; std::cout&lt;&lt;a; return a+1;&#125;//func4拥有了返回值//注意：可以不声明返回值类型，编译器会自己推导（C++14）//如果需要声明返回值，就这样写（C++11）：auto func5 = [](int a)-&gt;int&#123; std::cout&lt;&lt;a; return a+1;&#125; 现在，labmda已经拥有了一个函数所应该拥有的一切： 传入参数 函数体 返回值 名字 下面来使用它。 使用labmda变量（C++11）1234567auto func = [](int a)-&gt;int&#123; std::cout&lt;&lt;a; return a+1;&#125;int num = func(1);//可以将lambda表达式视为一个函数，像使用函数一样使用它。 接下来，我们来看看labmda的捕获列表。 捕获列表（C++11）lambda表达式可以“捕获”目前所处位置可见的变量，然后在函数体里面操作这些变量。 来看例子： 123456789int main()&#123; int message = 17; auto func = [message](int a)&#123; return a + message; &#125;; std::cout&lt;&lt;func(1);&#125;//输出18 将需要捕获的变量写进方括号，即可在函数体里面操作这个变量。（如果你在lambda函数体内使用了某个外部的局部变量又没有捕获，编译器会报错的。） 有两种捕获方式： 值捕获：相当于把外部变量复制一份放进lambda函数体里。 引用捕获：相当于创建外部变量的引用放进lambda函数体里，在lambda函数体里修改这个变量将影响到对应外部变量的值。 来看例子： 12345678910111213141516int var1 = 1;int var2 = 2;int var3 = 3;auto func1 = [var1]()&#123;&#125;;//这是默认情况，值捕获auto func1 = [var1, var2]()&#123;&#125;;//这是默认情况，值捕获，而且捕获了两个变量。auto func2 = [&amp;var1]()&#123;&#125;;//这是引用捕获auto func3 = [=]()&#123;&#125;;//对所有变量进行值捕获auto func4 = [&amp;]()&#123;&#125;;//对所有变量进行引用捕获auto func5 = [=,&amp;var2]()&#123;&#125;;//var2进行引用捕获，其他所有变量进行值捕获 基本语法就是这样，实际使用时可以自己类推。 （到这里你可能觉得捕获列表没啥用。我可以理解，你现在只需要简单了解一下，待会儿正式使用时你会惊叹它的威力的。） lambda参数自动类型推导（C++14）C++14允许lambda表达式的参数类型是“auto”，编译器将在编译时自动推导其类型。 好，这样我们就学完lambda表达式的基本功能了。现在，让我们迈入函数式编程的旅途吧！","categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"auto发展史","slug":"现代C++-1-auto发展史","date":"2022-09-18T15:59:06.000Z","updated":"2022-09-19T05:51:47.930Z","comments":true,"path":"2022/09/18/现代C++-1-auto发展史/","link":"","permalink":"http://example.com/2022/09/18/%E7%8E%B0%E4%BB%A3C++-1-auto%E5%8F%91%E5%B1%95%E5%8F%B2/","excerpt":"","text":"autoC++11 用auto在函数体内定义变量 auto声明普通函数返回值，接尾置返回值类型 decltype(auto)超级推导 C++14 自动推导auto声明的函数返回值 lambda参数可以是auto C++17 结构化绑定 C++20 concept 的一种声明方式","categories":[{"name":"现代C++","slug":"现代C","permalink":"http://example.com/categories/%E7%8E%B0%E4%BB%A3C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"lambda发展史","slug":"现代C++-3-lambda发展史.md","date":"2022-09-18T15:59:06.000Z","updated":"2022-09-19T05:51:33.346Z","comments":true,"path":"2022/09/18/现代C++-3-lambda发展史.md/","link":"","permalink":"http://example.com/2022/09/18/%E7%8E%B0%E4%BB%A3C++-3-lambda%E5%8F%91%E5%B1%95%E5%8F%B2.md/","excerpt":"","text":"","categories":[{"name":"现代C++","slug":"现代C","permalink":"http://example.com/categories/%E7%8E%B0%E4%BB%A3C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"引用","slug":"现代C++-2-引用.md","date":"2022-09-18T15:59:06.000Z","updated":"2022-09-19T05:51:38.884Z","comments":true,"path":"2022/09/18/现代C++-2-引用.md/","link":"","permalink":"http://example.com/2022/09/18/%E7%8E%B0%E4%BB%A3C++-2-%E5%BC%95%E7%94%A8.md/","excerpt":"","text":"","categories":[{"name":"现代C++","slug":"现代C","permalink":"http://example.com/categories/%E7%8E%B0%E4%BB%A3C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"三路比较","slug":"现代C++-4-三路比较.md","date":"2022-09-18T15:59:06.000Z","updated":"2022-09-19T05:51:25.044Z","comments":true,"path":"2022/09/18/现代C++-4-三路比较.md/","link":"","permalink":"http://example.com/2022/09/18/%E7%8E%B0%E4%BB%A3C++-4-%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83.md/","excerpt":"","text":"","categories":[{"name":"现代C++","slug":"现代C","permalink":"http://example.com/categories/%E7%8E%B0%E4%BB%A3C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"模型索引","slug":"Qt文档译注-2-模型索引","date":"2022-09-18T15:59:06.000Z","updated":"2022-09-19T05:21:28.376Z","comments":true,"path":"2022/09/18/Qt文档译注-2-模型索引/","link":"","permalink":"http://example.com/2022/09/18/Qt%E6%96%87%E6%A1%A3%E8%AF%91%E6%B3%A8-2-%E6%A8%A1%E5%9E%8B%E7%B4%A2%E5%BC%95/","excerpt":"123456789QModelIndex与QAbstractItemModel一同定义，用以索引模型（model）中的项（Item）。由于所有模型都是以“行“、”列”、“层级”结构组织的，我们可以使用统一的方式索引模型中的项。所有模型都使用QModelIndex作为模型的索引。QModelIndex内部包含了行信息、列信息与指向所属模型的指针，因此理论上可以做很多事。文档原文：https://doc.qt.io/qt-5/qmodelindex.html 详细信息","text":"123456789QModelIndex与QAbstractItemModel一同定义，用以索引模型（model）中的项（Item）。由于所有模型都是以“行“、”列”、“层级”结构组织的，我们可以使用统一的方式索引模型中的项。所有模型都使用QModelIndex作为模型的索引。QModelIndex内部包含了行信息、列信息与指向所属模型的指针，因此理论上可以做很多事。文档原文：https://doc.qt.io/qt-5/qmodelindex.html 详细信息 这个类可以用作QAbstractModel以及从它所派生的模型的索引。“视图”（view）、“代理”（delegate）和“选择模型”（selection models）都使用索引来定位模型中的项。 QModelIndex 的默认构造函数只能创建无效索引，有效的QModelIndex对象应由模型使用QAbstractItemModel::createIndex 函数创建。模型中的最高级项的父索引是无效索引。 QModelIndex 不止一个构造函数，但是除了无参数的构造函数外，其他的构造函数（能创造出有效索引的构造函数）都被设置为私有 QAbstractItemModel 是 QModelIndex 的友元，它可以访问这些私有构造函数来创建出有效的索引。 所有模型都是 QAbstractItemModel 的子类（或间接子类），它们继承了QAbstractItemModel的createIndex函数。 QModelIndex可以用来引用模型中的项，它包含确定这个项在模型中的位置所需的所有信息。索引拥有行信息、列信息，并且可能拥有父索引，可以使用row()、column()和parent()函数来获取这些信息。模型中的每个顶级项都由一个没有父索引的模型索引表示，在这种情况下，parent()将返回一个无效的模型索引，这种情况相当于使用QModelIndex()来构造无效索引。 （Qt5.15） QModelIndex 拥有这些私有变量： ​ int r, c; ​ quintptr i; ​ const QAbstractItemModel *m; 其中 r 与 c 是行列信息，m 是其所属的模型的指针。i 是用来把索引和底层数据结构联系起来的 void 指针。 QModelIndex 没有指向其父索引的指针，QModelIndex 的 parent 函数是通过调用其对应模型的 parent 函数实现的。 要获取模型中某个项的索引，请调用QAbstractIemModel::index()，这个函数需要三个参数：行数、列数、父索引的引用。引用模型中的顶级项时，应提供无效索引作为父索引。 QAbstractIemModel::index()是一个纯虚函数，各个模型有不同的实现。 接口： QModelIndex QAbstractItemModel::index(int row, int column, const QModelIndex &amp;parent = QModelIndex()) const 第三个参数已经默认是无效索引，因此创建顶级项索引时传一个无效索引进去其实是多此一举。 model() 函数的作用是：返回索引对应模型的指针（const QAbstractItemModel*）。 child() 函数的作用是：获取该索引的子项目。 sibling() 函数的作用是：遍历模型中与本索引同级别的项。 注意：应立即使用模型索引，然后丢弃。在调用更改模型结构或删除项的模型函数后，不应认为索引仍然有效。如果需要长时间保留模型索引，请使用QPersistentModelIndex。 另请参见模型/视图编程、QPersistentModelIndex和QAbstractItemModel。 成员函数QModelIndex::QModelIndex()创建无效模型索引，用以指示模型中的某位置无效。 另请参见isValid()和QAbstractItemModel。 int QModelIndex::column()const返回索引所引用的元素所在的列数。 QVariant QModelIndex::data(int role=Qt::DisplayRole)const给定角色(role)，返回索引引用的项的数据。 Qt::ItemFlags QModelIndex::flags() const返回索引引用的项的标志(flag)。 此函数在Qt 4.2中引入。 quintptr QModelIndex::internalId() const返回将索引与内部数据结构关联的quintptr，这个quintptr被模型所使用。 另请参见QAbstractItemModel::createIndex()。 void* QModelIndex::internalPointer() const返回将索引与内部数据结构关联的void*指针，这个指针被模型所使用。 另请参见QAbstractItemModel::createIndex()。 bool QModelIndex::isValid()const如果此模型索引有效，则返回true；否则返回false。 有效索引属于模型，并且具有非负的行号和列号。 另请参见model()、row()和column()。 如果模型索引内部那个指向模型的指针非空，而且行列数非负，那么这个索引有效。 const QAbstractItemModel* QModelIndex::model()const返回指向此索引对应模型的指针。 返回值是常量指针，因为调用模型的非常量函数可能会使模型索引无效，并可能使应用程序崩溃。 QModelIndex QModelIndex::parent()const返回模型索引的父索引，如果没有父索引，则返回QModelIndex()。 另请参见 sibling() 和 model()。 int QModelIndex::row()const返回索引所引用的元素所在的列数。 QModelIndex QModelIndex::sibling(int row，int column)const返回该索引的兄弟。如果此位置没有兄弟，则返回无效的QModelIndex。 另请参见 parent(), siblingAtColumn(), 和 siblingAtRow()。 QModelIndex QModelIndex::siblingAtColumn(int column)const返回该索引的当前列的兄弟。如果此位置没有兄弟，则返回无效QModelIndex。 此函数在Qt 5.11中引入。 另请参见sibling() and siblingAtRow()。 QModelIndex QModelIndex::siblingAtRow(int row) const返回该索引的当前行的兄弟。如果此位置没有兄弟，则返回无效QModelIndex。 此函数在Qt 5.11中引入。 另请参见sibling() and siblingAtColumn()。 bool QModelIndex::operator=(const QModelIndex &amp;other)const如果此模型索引与其他模型索引引用的位置不同，则返回true；否则返回false。 bool QModelIndex::operator&lt;(const QModelIndex &amp;other)const如果此模型索引小于其他模型索引，则返回true；否则返回false。 小于计算对开发人员没有直接的帮助，没有定义具有不同父级的索引进行比较的方式。此运算符的存在只是为了使该类可以与QMap一起使用。 Qt 4.1中引入了此函数。 bool QModelIndex::operator==(const QModelIndex&amp; other)const如果此模型索引引用的位置与其他模型索引相同，则返回true；否则返回false。 与其他模型索引进行比较时，将使用内部数据指针、行、列和模型值。","categories":[{"name":"Qt技术文档","slug":"Qt技术文档","permalink":"http://example.com/categories/Qt%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"时间库","slug":"现代C++-7-时间库","date":"2022-09-18T15:59:06.000Z","updated":"2022-09-19T05:50:41.318Z","comments":true,"path":"2022/09/18/现代C++-7-时间库/","link":"","permalink":"http://example.com/2022/09/18/%E7%8E%B0%E4%BB%A3C++-7-%E6%97%B6%E9%97%B4%E5%BA%93/","excerpt":"","text":"声明：带星号的章节为小贴士，知识点较为琐碎，可以选择暂时不读，我会在需要时提供跳转链接。 C++11中引入了时间库。 需要#include 时间类时间库中主要有两个大类：时间点类和时间段类 下面是时间段类演示 12345678std::chrono::seconds time1(60);//定义了一个名字叫time1的 “时间段” 类型的变量，值为60秒std::chrono::hours time2(1);//定义了一个名字叫time2的 “时间段” 类型的变量，值为1小时//同理还有分钟minutes，毫秒milliseconds，微秒macroseconds，纳秒nanoseconds//这很好想明白吧 下面是时间点类演示 1234567std::chrono::steady_clock::time_point t1;//没错，这个类的名字叫std::chrono::steady_clock::time_pointt1 = std::chrono::steady_clock::now();//没错，这个函数叫std::chrono::steady_clock::now()，它可以获取当前时间 时间运算与输出小学的时候我们就学过：（别死记硬背，自己推导） 时间点 + 时间点 没有意义 时间点 - 时间点 = 时间段 时间点 ± 时间段 = 时间点 时间段 ± 时间段 = 时间段 这个库通过运算符重载实现了这样的加减转化，就是说，你可以将两个时间点相减，得到的直接是一个时间段，神奇吧。 比方说我们要测一大段代码的执行时间 1234567891011auto t1 = std::chrono::steady_clock::time_point::now();//auto真是我们的好伙伴//一大段代码//一大段代码//一大段代码auto t2 = std::chrono::steady_clock::time_point::now();auto duration = t2 - t1;//这里默认推导是纳秒，不想要纳秒可以不用类型推导 好，这样就得到一个时间段了，接下来要把它输出。 12std::cout&lt;&lt;duration.count();//这里duration.count()返回的是一个long long类型的值 想转化一下duration的单位？ 1234duration = std::chrono::duration_cast&lt;要转化成的类型&gt;(duration);//这里 “要转化的类型” 就是前面提到的时间段类//比如 std::chrono::seconds 这些便是所有常用操作了。 对了这个库没法输出时间点类型，真遗憾~","categories":[{"name":"现代C++","slug":"现代C","permalink":"http://example.com/categories/%E7%8E%B0%E4%BB%A3C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"RAII","slug":"现代C++-6-RAII","date":"2022-09-18T15:59:06.000Z","updated":"2022-09-19T05:50:54.534Z","comments":true,"path":"2022/09/18/现代C++-6-RAII/","link":"","permalink":"http://example.com/2022/09/18/%E7%8E%B0%E4%BB%A3C++-6-RAII/","excerpt":"","text":"","categories":[{"name":"现代C++","slug":"现代C","permalink":"http://example.com/categories/%E7%8E%B0%E4%BB%A3C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"format库","slug":"现代C++-5-format库","date":"2022-09-18T15:59:06.000Z","updated":"2022-09-19T05:51:11.352Z","comments":true,"path":"2022/09/18/现代C++-5-format库/","link":"","permalink":"http://example.com/2022/09/18/%E7%8E%B0%E4%BB%A3C++-5-format%E5%BA%93/","excerpt":"","text":"","categories":[{"name":"现代C++","slug":"现代C","permalink":"http://example.com/categories/%E7%8E%B0%E4%BB%A3C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"创建子类模型","slug":"Qt文档译注-1-创建子类模型","date":"2022-09-18T15:55:43.000Z","updated":"2022-09-19T05:21:39.257Z","comments":true,"path":"2022/09/18/Qt文档译注-1-创建子类模型/","link":"","permalink":"http://example.com/2022/09/18/Qt%E6%96%87%E6%A1%A3%E8%AF%91%E6%B3%A8-1-%E5%88%9B%E5%BB%BA%E5%AD%90%E7%B1%BB%E6%A8%A1%E5%9E%8B/","excerpt":"子类模型需要提供 QabstractemModel 基类中定义的许多虚函数的实现。需要实现的函数数量取决于模型的类型——它是为视图提供简单的列表、表格还是复杂的项目层次结构。从 QAbstractListModel 和 QAbstractTableModel 继承的模型可以利用它们所提供函数的默认实现。以树状结构组织数据项的模型必须为QabstractemModel中的许多虚函数提供实现。","text":"子类模型需要提供 QabstractemModel 基类中定义的许多虚函数的实现。需要实现的函数数量取决于模型的类型——它是为视图提供简单的列表、表格还是复杂的项目层次结构。从 QAbstractListModel 和 QAbstractTableModel 继承的模型可以利用它们所提供函数的默认实现。以树状结构组织数据项的模型必须为QabstractemModel中的许多虚函数提供实现。 需要在模型子类中实现的功能可分为三组： 数据项处理：所有模型都需要实现功能，以使视图和委托能够查询模型的维度、检查项目和检索数据。 导引和索引创建：具有层次结构的模型需要提供视图可以调用的功能，以导引它们展示的树状结构；以及获取项的索引。 拖放支持和MIME类型处理：模型继承了控制内部和外部拖放操作的函数。这些函数允许按照其他组件和应用程序可以理解的MIME类型来描述数据项。 数据项处理模型可以提供对其提供的数据项的不同访问级别：它们可以是简单的只读项，或者能支持调整大小操作，有的甚至允许编辑。 只读权限如果模型提供的数据项是只读的，在子类中这些函数需要被实现： flags() 其他组件用于获取有关模型提供的每个项目的信息的标志在许多模型中，标志的组合应该包括Qt：：ItemIsEnabled和Qt：：ItemIsSelectable。 data() 用于向视图和委托提供项数据。通常，模型只需要为Qt：：DisplayRole和用户特定的角色(role)提供数据，但为Qt：：ToolTipRole、Qt：：AccessibleTextRole和Qt：：AccessibleDescriptionRole提供数据也是一种很好的做法。有关与每个角色关联的类型的信息，请参阅Qt：：ItemDataRole枚举文档。 headerData() 为视图提供要在其标头中显示的信息。该信息仅由可以显示标头信息的视图检索。 rowCount() 模型提供的数据行数 这四个函数必须在所有类型的模型中实现，包括列表模型（QAbstractListModel 子类）和表模型（QAbstractTableModel 子类）。 此外，必须在QAbstractTableModel和QAbstractItemModel的直接子类中实现以下功能： columnCount() 模型提供的数据列数。列表模型不提供此功能，因为它已在QAbstractListModel中实现。 可编辑数据项可编辑模型允许修改数据项，并可能提供允许插入和删除行和列的功能。要启用编辑，必须实现下列函数： flags() 必须为每个项目返回适当的标志(flag)组合。特别的，除了应用于只读模型中的项的值之外，此函数返回的值还必须包括Qt：：ItemIsEditable。 setData() 用于修改与指定模型索引关联的数据项。为了能够接受用户界面元素提供的用户输入，此函数必须处理与Qt：：EditRole关联的数据。该实现还可以接受与Qt：：ItemDataRole指定的许多不同类型的角色相关联的数据。更改数据项后，模型必须发出dataChanged（）信号，以通知其他组件该更改。 setHeaderData() 用于修改水平和垂直标头信息。更改数据项后，模型必须发出headerDataChanged（）信号，以通知其他组件该更改。 可变容量模型所有类型的模型都可以支持插入和删除行。表模型和层次模型还可以支持插入和删除列。而在模型尺寸发生更改之前和之后，要将更改通知给其他组件。因此，可实现以下函数以允许调整模型的容量，但这些函数的实现必须确保适当的函数被调用以通知与这个模型相连接的视图和委托： insertRows 用于向模型中添加新行和数据项。注意必须在插入操作之前调用beginInsertRows（），插入完成后立即调用endInsertRows（）。 removeRows 用于从所有类型的模型中删除行及其包含的数据项。在删除行之前，必须调用beginRemoveRows（），完成后立即调用endRemoveRows（）。 insertColumns 用于向模型中添加新列和数据项。注意必须在插入操作之前调用beginInsertColumns（），插入完成后立即调用endInsertColumns（）。 removeColumns 用于从所有类型的模型中删除列及其包含的数据项。在删除行之前，必须调用beginRemoveColumns（），完成后立即调用endRemoveColumns（）。 通常，如果操作成功，这些函数应返回true。然而，可能存在操作仅部分成功的情况；例如，可以插入的行数小于指定的行数。在这种情况下，模型应返回false以表示操作失败并指示相关组件处理这种情况。 在调整容量API的实现中调用函数发出的信号使相关的组件有机会在某些数据不可用之前采取行动。使用begin和end函数封装insert和remove操作，还可以使模型正确管理持久模型索引。 通常，begin和end函数能够通知其他组件模型底层结构的更改。对于模型结构的更复杂更改，可能涉及内部重组、数据排序或任何其他结构更改，有必要按顺序执行以下操作： 发出layoutAboutToBeChanged（）信号 更新表示模型结构的内部数据。 使用changePersistentIndexList（）更新持久索引 发出layoutChanged（）信号。 此序列可用于任何结构更新，是一种更高级和更方便的保护方法。例如，如果一个有200万行的模型需要删除所有奇数行，即有100万个长度为1的裁剪范围。可以使用beginRemoveRows和endRemoveRows 100万次，但这显然效率低下。相反，这可以视作一个布局更改来发出信号，它会立即更新所有必要的持久性索引。 模型数据的惰性填充模型数据的惰性填充有效地延迟对模型信息的请求，直到视图实际需要它为止。 一些模型需要从远程源获取数据，或者必须执行耗时的操作以获取有关数据组织方式的信息。由于视图通常要求尽可能多的信息以准确显示模型数据，因此限制返回给它们的信息量以减少不必要的后续数据请求可能会很有用。 在层次模型中，查找给定项的子项数量是一项代价高昂的操作，因此确保仅在必要时调用模型的rowCount（）非常有用。在这种情况下，可以重新实现hasChildren（）函数，为视图提供一种廉价的方法来检查子项的存在，对于QTreeView，draw the appropriate decoration for their parent item. 无论hasChildren（）的重新实现是否返回true或false，视图都可能不需要调用rowCount（）来确定存在多少子级。例如，如果父项未展开以显示子项，则QTreeView不需要知道有多少子项。 如果知道许多项都有子项，那么重新实现hasChildren（）以无条件返回true有时是一种有用的方法。这使得检查每个数据项子项的操作被推迟到之后进行，同时使模型数据的初始总体尽可能快。唯一的缺点是，没有子项的数据项可能在某些视图中显示不正确，直到用户尝试查看这些数据项。 导航(Navigation)和模型索引创建层次模型需要提供函数以导航它们公开的树状结构，供视图调用，并让视图可以获取项的索引。 父级和子级由于暴露给视图的结构由底层数据结构决定，因此每个模型子类都可以通过提供以下函数的实现来创建自己的模型索引： index 给定父项的模型索引，此函数允许视图和委托访问该项的子项。如果找不到与指定的行、列和父模型索引相对应的有效子项，则函数必须返回QModelIndex（），这是一个无效的模型索引。 parent 提供与任何给定子项的父项相对应的模型索引。如果指定的模型索引对应于模型中的顶级项，或者如果模型中没有有效的父项，则函数必须返回使用空QModelIndex（）构造函数创建的无效模型索引。 上述两个函数都使用createIndex（）工厂函数来生成索引，供其他组件使用。模型通常会向该函数提供一些唯一标识符，以确保模型索引稍后可以与其相应的项重新关联。 拖放支持和MIME类型处理模型/视图类支持拖放操作，提供了许多应用程序所需的默认行为。但是，也可以自定义项目在拖放操作期间的编码方式，默认情况下是复制还是移动数据项，以及如何将数据项插入现有模型。 此外，方便视图类（convenience view）实现了专门的行为，这些行为应该严格遵循现有开发人员的预期。“方便视图”部分提供了此行为的概述。 MIME数据默认情况下，内置模型和视图使用内部MIME类型（application/x-QAbstracteModelDataList）传递有关模型索引的信息。这将指定数据项列表的数据，其中包含每个项目的行号和列号，以及关于每个项目支持的角色的信息。 使用此MIME类型编码的数据可以通过使用包含要序列化的项的QModelIndexList调用QAbstractItemModel：：mimeData（）来获得。 在自定义模型中实现拖放支持时，可以通过重新实现以下函数以专用格式导出数据项： mimeData 此函数可以重写，以非默认application/x-qabstractemodeldatalist内部MIME类型的格式返回数据。子类可以从基类获得默认的QMimeData对象，并以其他格式向其添加数据。 对于许多模型，以MIME类型（如text/plain和image/png）表示的通用格式提供项目的内容非常有用。请注意，可以使用QMimeData：：setImageData（）、QMimeData：：setColorData（）和QMimeData：：setHtml（）函数轻松地将图像、颜色和HTML文档添加到QMimeData对象中。 接受拖放数据在视图上执行拖放操作时，将查询基础模型，以确定其支持的操作类型以及可以接受的MIME类型。此信息由qabstractemmodel：：supportedDropActions（）和qabstractemmodel：：mimeTypes（）函数提供。不重写QAbstractItemModel提供的实现的模型支持复制操作和项的默认内部MIME类型。 将序列化的项数据放到视图中时，将使用QabstractemModel：：dropMimeData（）的实现将数据插入当前模型。此功能的默认实现不会覆盖模型中的任何数据；相反，它尝试将数据项作为项的同级或子项插入。 要利用QabstractemModel对内置MIME类型的默认实现，新模型必须提供以下函数的重新实现： insertRows（） 这些函数使模型能够使用qabstractemmodel：：dropMimeData（）提供的现有实现自动插入新数据。 insertColumns（） setData 允许用项目填充新行和新列。 setItemData 此函数为填充新项提供更有效的支持。 要接受其他形式的数据，必须重新实现以下功能： supportDropActions 用于返回拖放操作的组合，指示模型接受的拖放操作类型。 mimeTypes 用于返回可由模型解码和处理的MIME类型列表。通常，支持输入到模型中的MIME类型与它在编码数据以供外部组件使用时可以使用的类型相同。 dropMimeData 对通过拖放操作传输的数据执行实际解码，确定在模型中设置数据的位置，并在必要时插入新行和新列。如何在子类中实现此功能取决于每个模型公开的数据的要求。 如果dropMimeData（）函数的实现通过插入或删除行或列来更改模型的维度，或者如果修改了数据项，则必须小心确保发出了所有的相关信号。这时候调用子类中其他函数的重新实现，如setData（）、insertRows（）和insertColumns（），就可以确保模型的行为一致。 为了确保拖动操作正常工作，必须重新实现以下从模型中删除数据的功能： removeRows（） removeRow（） removeColumns（） removeColumns（） 有关在项目视图中拖放的详细信息，请参阅在项目视图中使用拖放。 便利性视图方便视图（QListWidget、QTableWidget和QTreeWidget）覆盖了默认的拖放功能，以提供不太灵活但更自然的行为，适用于许多应用程序。例如，由于更常见的做法是将数据放入QTableWidget中的单元格，用传输的数据替换现有内容，因此模型将设置目标项的数据，而不是在模型中插入新行和列。有关在便利视图中拖放的详细信息，请参见在项目视图中使用拖放。 针对大量数据的性能优化canFetchMore（）函数检查父级是否有更多可用数据，并相应地返回true或false。函数的作用是：根据指定的父级获取数据。例如，可以在涉及增量数据的数据库查询中组合这两个功能，以填充QabstractemModel。我们重新实现canFetchMore（）以指示是否有更多数据需要提取，并根据需要使用fetchMore（）填充模型。 另一个例子是动态填充的树模型，当树模型中的一个分支展开时，我们将重新实现fetchMore（）。 如果重新实现fetchMore（）将行添加到模型中，则需要调用beginInsertRows（）和endInsertRows（）。此外，必须重新实现canFetchMore（）和fetchMore（），因为它们的默认实现返回false，并且不执行任何操作。","categories":[{"name":"Qt技术文档","slug":"Qt技术文档","permalink":"http://example.com/categories/Qt%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]}],"categories":[{"name":"C++函数式编程","slug":"C-函数式编程","permalink":"http://example.com/categories/C-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"现代C++","slug":"现代C","permalink":"http://example.com/categories/%E7%8E%B0%E4%BB%A3C/"},{"name":"Qt技术文档","slug":"Qt技术文档","permalink":"http://example.com/categories/Qt%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]}